<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rodé Lajos - Havazó v8</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body {
      margin: 0;
      padding: 0;
      background: #f2f4f8;
      color: #222;
    }
    h1 {
      font-size: 1.4rem;
      margin: 0 0 0.5rem 0;
    }
    .page {
      max-width: 1100px;
      margin: 0 auto;
      padding: 1rem;
    }

    .top-bar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.75rem;
    }
    .current-folder {
      font-size: 0.9rem;
      color: #333;
      flex: 1;
      min-width: 180px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .current-folder span.folder-name {
      font-weight: 700;
    }
    .folder-button {
      padding: 0.3rem 0.7rem;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      background: #e9ecef;
      color: #222;
    }
    .folder-button:hover {
      box-shadow: 0 1px 4px rgba(0,0,0,0.18);
    }

    .main {
      background: transparent;
    }

    .snow-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
      gap: 0.5rem;
    }
    .snow-list-empty {
      font-size: 0.9rem;
      color: #555;
    }

    /* DIA: fehér, lekerekített kártya, benne fent a thumbnail, alatta a mennyiség */
    .snow-item {
      background: #fff;
      border-radius: 10px;
      padding: 0.6rem 0.6rem 0.55rem;
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      gap: 0.35rem;
    }

    /* Thumbnail: álló téglalap, 15:16 arány, körben fehér keret a kártyától */
    .snow-thumb {
      width: 100%;
      max-width: 140px;
      aspect-ratio: 15 / 16; /* 600x640 arány */
      border-radius: 6px;
      overflow: hidden;
      background: #001633;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    .snow-thumb img {
      width: 100%;
      height: 100%;
      object-fit: contain;  /* teljes kép látszik, nem vágjuk le a kód feliratot */
      display: block;
    }
    .snow-thumb-placeholder {
      font-size: 0.7rem;
      color: #555;
      text-align: center;
      padding: 0.25rem;
    }

    .snow-qty {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
      flex-shrink: 0;
      font-size: 0.8rem;
    }
    .snow-qty input[type="number"] {
      width: 3.2rem;
      padding: 0.1rem 0.25rem;
      font-size: 0.8rem;
      text-align: right;
    }

    .bottom-bar {
      margin-top: 0.75rem;
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      gap: 0.75rem;
    }
    .summary {
      font-size: 0.85rem;
      color: #333;
      flex: 1;
      min-width: 180px;
    }
    .bottom-right {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      align-items: stretch;       /* sorok teljes szélességen */
      min-width: 260px;
      max-width: 360px;
    }
    .bottom-row {
      display: flex;
      flex-wrap: nowrap;
      gap: 0.5rem;
      justify-content: space-between; /* bal és jobb vég igazítása egy vonalra */
      align-items: center;
      width: 100%;
    }
    .bottom-row button {
      padding: 0.35rem 0.7rem;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      transition: background 0.15s, box-shadow 0.15s, transform 0.05s;
    }
    .bottom-row button.primary {
      background: #0d6efd;
      color: #fff;
    }
    .bottom-row button.secondary {
      background: #e9ecef;
      color: #222;
    }
    .bottom-row button:hover {
      box-shadow: 0 1px 4px rgba(0,0,0,0.18);
    }
    .bottom-row button:active {
      transform: translateY(1px);
      box-shadow: none;
    }
    .set-all-input {
      width: 3.2rem;
      padding: 0.1rem 0.25rem;
      font-size: 0.8rem;
      text-align: right;
    }
    .set-all-label {
      font-size: 0.8rem;
    }
    .bottom-row-left {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }
    .bottom-row-right {
      display: flex;
      align-items: center;
    }
  </style>
</head>
<body>
<div class="page">
  <h1>Rodé Lajos - Havazó v8</h1>

  <div class="top-bar">
    <div class="current-folder">
      Aktuális mappa:
      <span id="currentFolderName" class="folder-name">nincs kijelölve</span>
    </div>
    <button id="chooseFolderBtn" type="button" class="folder-button">
      Mappa kijelölése
    </button>
    <input id="folderInput" type="file" webkitdirectory multiple style="display:none">
  </div>

  <div class="main">
    <div id="snowList" class="snow-list">
      <div class="snow-list-empty">Nincs betöltött hópehely-kép.</div>
    </div>
  </div>

  <div class="bottom-bar">
    <div class="summary">
      Hópelyhek száma: <span id="countSnowflakes">0</span>,
      összes darab: <span id="countPieces">0</span>
    </div>
    <div class="bottom-right">
      <!-- felső sor: két gomb -->
      <div class="bottom-row">
        <button id="loadListBtn" class="secondary">Lista betöltése</button>
        <button id="generateMissingBtn" class="secondary">Hiányzó képek generálása</button>
      </div>
      <!-- alsó sor: [szám] db [mind] | MENTÉS -->
      <div class="bottom-row">
        <div class="bottom-row-left">
          <input id="setAllQtyInput" class="set-all-input" type="number" min="0" step="1" value="1">
          <span class="set-all-label">db</span>
          <button id="setAllQtyBtn" class="secondary">mind</button>
        </div>
        <div class="bottom-row-right">
          <button id="saveListBtn" class="primary">MENTÉS</button>
        </div>
      </div>
    </div>
  </div>

  <input id="loadListInput" type="file" accept="application/json" style="display:none">
</div>

<script>
  const DXF_TARGET_SIZE = 100.0; // mm
  const CELL_GAP = 2.0;          // mm
  const CELL_MARGIN = CELL_GAP / 2;

  let snowItems = [];            // {file?, name, code, qty, thumbUrl?}
  let imagesByCode = new Map();  // code -> {file, name}
  let geometryCache = new Map(); // code -> {contoursWithFlags:[{points, isOuter}]}

  // --- PEHELY-kód olvasása JPG COM szegmensből ---
  function parseCodeFromJpegArrayBuffer(arrayBuffer) {
    const bytes = new Uint8Array(arrayBuffer);
    if (bytes.length < 4 || bytes[0] !== 0xFF || bytes[1] !== 0xD8) {
      return null;
    }

    let i = 2;
    while (i + 4 <= bytes.length) {
      if (bytes[i] !== 0xFF) {
        i++;
        continue;
      }
      const marker = bytes[i + 1];

      if (marker === 0xD9 || marker === 0xDA) {
        break;
      }

      const len = (bytes[i + 2] << 8) | bytes[i + 3];
      if (len < 2 || i + 2 + len > bytes.length) {
        break;
      }

      if (marker === 0xFE) {
        const start = i + 4;
        const end = i + 2 + len;
        const comBytes = bytes.subarray(start, end);
        const decoder = new TextDecoder("utf-8");
        const text = decoder.decode(comBytes);
        const idx = text.indexOf('PEHELY-');
        if (idx !== -1) {
          const code = text.substring(idx + 7).trim();
          if (code) return code;
        }
      }

      i += 2 + len;
    }
    return null;
  }

  function readCodeFromFile(file) {
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const buffer = e.target.result;
          const code = parseCodeFromJpegArrayBuffer(buffer);
          resolve(code);
        } catch (err) {
          console.error('Hiba kód olvasásakor', err);
          resolve(null);
        }
      };
      reader.onerror = () => resolve(null);
      reader.readAsArrayBuffer(file);
    });
  }

  // --- UI segédek ---
  function setCurrentFolderLabel(files) {
    const labelSpan = document.getElementById('currentFolderName');
    if (!files || !files.length) {
      labelSpan.textContent = 'nincs kijelölve';
      return;
    }
    const f0 = files[0];

    if (typeof f0.path === 'string') {
      // Ha valamilyen speciális környezetben mégis elérhető a teljes path
      labelSpan.textContent = f0.path;
      return;
    }

    // Böngészőben csak relatív elérési út érhető el (pl. "Próbamappa/valami.jpg").
    if (f0.webkitRelativePath) {
      const p = f0.webkitRelativePath;
      const lastSlash = p.lastIndexOf('/');
      // csak a mappanév (vagy relatív mappa-rész) jelenjen meg, ne az első fájlnév
      if (lastSlash > 0) {
        labelSpan.textContent = p.substring(0, lastSlash);
      } else {
        labelSpan.textContent = p;
      }
    } else {
      labelSpan.textContent = f0.name || '(kiválasztott fájlok)';
    }
  }

  function clearSnowItems() {
    for (const item of snowItems) {
      if (item.thumbUrl) {
        URL.revokeObjectURL(item.thumbUrl);
      }
    }
    snowItems = [];
  }

  function updateSummary() {
    const snowCount = snowItems.length;
    let pieceCount = 0;
    for (const item of snowItems) {
      const q = parseInt(item.qty, 10);
      if (Number.isFinite(q) && q > 0) {
        pieceCount += q;
      }
    }
    document.getElementById('countSnowflakes').textContent = snowCount;
    document.getElementById('countPieces').textContent = pieceCount;
  }

  function renderSnowList() {
    const listEl = document.getElementById('snowList');
    listEl.innerHTML = '';

    if (!snowItems.length) {
      const emptyDiv = document.createElement('div');
      emptyDiv.className = 'snow-list-empty';
      emptyDiv.textContent = 'Nincs betöltött hópehely-kép.';
      listEl.appendChild(emptyDiv);
      updateSummary();
      return;
    }

    snowItems.forEach((item) => {
      const row = document.createElement('div');
      row.className = 'snow-item';

      const thumbDiv = document.createElement('div');
      thumbDiv.className = 'snow-thumb';
      if (item.thumbUrl) {
        const img = document.createElement('img');
        img.src = item.thumbUrl;
        img.alt = item.name || 'Hópehely';
        thumbDiv.appendChild(img);
      } else {
        const ph = document.createElement('div');
        ph.className = 'snow-thumb-placeholder';
        ph.textContent = 'Nincs kép';
        thumbDiv.appendChild(ph);
      }

      const qtyDiv = document.createElement('div');
      qtyDiv.className = 'snow-qty';
      const input = document.createElement('input');
      input.type = 'number';
      input.min = '0';
      input.step = '1';
      input.value = item.qty != null ? item.qty : 1;

      input.addEventListener('input', () => {
        let v = parseInt(input.value, 10);
        if (!Number.isFinite(v) || v < 0) v = 0;
        item.qty = v;
        input.value = v;
        updateSummary();
      });

      const suffix = document.createElement('span');
      suffix.textContent = 'db';

      qtyDiv.appendChild(input);
      qtyDiv.appendChild(suffix);

      row.appendChild(thumbDiv);
      row.appendChild(qtyDiv);

      listEl.appendChild(row);
    });

    updateSummary();
  }

  // --- Mappaválasztás ---
  async function handleFolderSelection(fileList) {
    clearSnowItems();
    imagesByCode.clear();
    geometryCache.clear();

    const files = Array.from(fileList || []);
    setCurrentFolderLabel(files);

    if (!files.length) {
      renderSnowList();
      return;
    }

    const jpgFiles = files.filter(f => /\.jpe?g$/i.test(f.name));
    if (!jpgFiles.length) {
      renderSnowList();
      return;
    }

    for (const file of jpgFiles) {
      const code = await readCodeFromFile(file);
      if (code) {
        const thumbUrl = URL.createObjectURL(file);
        const item = {
          file,
          name: file.name,
          code,
          qty: 1,
          thumbUrl
        };
        snowItems.push(item);
        if (!imagesByCode.has(code)) {
          imagesByCode.set(code, { file, name: file.name });
        }
      }
    }

    renderSnowList();
  }

  // --- Paraméterek a PEHELY-kódból ---
  function paramsFromCode(codeString) {
    const parts = codeString.split('-');
    if (parts.length < 12) {
      throw new Error('Érvénytelen PEHELY kód: ' + codeString);
    }

    const [
      angleStr, ratioStr, spaceStr, redStr,
      tipCode, tipScaleStr, tipOnlyFlag, tipCenterFlag, trunkFlag,
      armsStr, minRectStr, growFlag
    ] = parts;

    const angle   = parseFloat(angleStr) || 0;
    const ratio   = parseFloat(ratioStr) || 0;
    const spacing = parseFloat(spaceStr) || 0;
    const red     = parseFloat(redStr)   || 0;

    let tipMode = 0;
    if      (tipCode === '3S') tipMode = 1;
    else if (tipCode === 'YY') tipMode = 2;
    else if (tipCode === '6S') tipMode = 3;
    else if (tipCode === '4S') tipMode = 4;

    const tipScale   = parseFloat(tipScaleStr);
    const arms       = parseInt(armsStr, 10);
    const minRectMm  = parseFloat(minRectStr);

    return {
      branchAngleDeg:    angle,
      rectAspectPercent: ratio,
      spacingPercent:    spacing,
      reductionPercent:  red,
      tipMode,
      tipScale:          Number.isFinite(tipScale) ? tipScale : 1,
      tipOnly:           (tipOnlyFlag   === 'Y'),
      tipAtCenter:       (tipCenterFlag === 'Y'),
      showTrunk:         (trunkFlag     === 'Y'),
      armCount:          Number.isFinite(arms) ? arms : 6,
      minRectMm:         Number.isFinite(minRectMm) ? minRectMm : 0,
      growSmallRects:    (growFlag === 'Y')
    };
  }

  // --- Geometria (PEHELY kóddal kompatibilis) ---

  function makeRectFromBase(bx, by, length, width, angleRad) {
    const d = { x: Math.cos(angleRad), y: Math.sin(angleRad) };
    const n = { x: -Math.sin(angleRad), y: Math.cos(angleRad) };

    const halfL = length / 2;
    const halfW = width / 2;

    const cx = bx + d.x * halfL;
    const cy = by + d.y * halfL;

    const p1 = [ cx + n.x * halfW + d.x * halfL, cy + n.y * halfW + d.y * halfL ];
    const p2 = [ cx - n.x * halfW + d.x * halfL, cy - n.y * halfW + d.y * halfL ];
    const p3 = [ cx - n.x * halfW - d.x * halfL, cy - n.y * halfW - d.y * halfL ];
    const p4 = [ cx + n.x * halfW - d.x * halfL, cy + n.y * halfW - d.y * halfL ];

    return [p1, p2, p3, p4, p1.slice()];
  }

  function scalePolygon(poly, scale) {
    if (!poly || poly.length < 2 || scale === 1) return poly;
    const unique = poly.slice(0, poly.length - 1);
    if (!unique.length) return poly;

    let cx = 0, cy = 0;
    for (const [x, y] of unique) {
      cx += x; cy += y;
    }
    cx /= unique.length;
    cy /= unique.length;

    const scaled = unique.map(([x, y]) => [
      cx + (x - cx) * scale,
      cy + (y - cy) * scale
    ]);
    scaled.push(scaled[0].slice());
    return scaled;
  }

  function buildSingleTreeSegments(params) {
    const segments = [];

    const trunkLength = 50;
    const aspect = Math.max(0.02, params.rectAspectPercent / 100.0);
    const trunkWidth = trunkLength * aspect;

    const trunkAngle = Math.PI / 2;
    const spacing = params.spacingPercent;
    const angleOffset = params.branchAngleDeg * Math.PI / 180.0;
    const reduction = Math.max(0, Math.min(0.95, params.reductionPercent / 100.0));
    const tipMode = params.tipMode;
    const tipScale = Number.isFinite(params.tipScale) ? params.tipScale : 1;

    segments.push({
      bx: 0, by: 0,
      length: trunkLength,
      width: trunkWidth,
      angle: trunkAngle,
      tipMode,
      tipScale,
      isTrunk: true
    });

    const count = Math.floor(100 / spacing);
    if (count <= 0) return segments;

    const dTrunk = { x: Math.cos(trunkAngle), y: Math.sin(trunkAngle) };
    const signs = [+1, -1];

    for (let i = 1; i <= count; i++) {
      const t = i * spacing / 100.0;
      const posOnTrunk = trunkLength * t;

      const baseX = dTrunk.x * posOnTrunk;
      const baseY = dTrunk.y * posOnTrunk;

      let branchLength;
      if (reduction === 0) {
        branchLength = trunkLength;
      } else {
        branchLength = trunkLength * Math.pow(1 - reduction, i);
      }
      const branchWidth = branchLength * aspect;

      for (const sign of signs) {
        const branchAngle = trunkAngle + sign * angleOffset;
        segments.push({
          bx: baseX, by: baseY,
          length: branchLength,
          width: branchWidth,
          angle: branchAngle,
          tipMode,
          tipScale,
          isTrunk: false
        });

        const dBranch = { x: Math.cos(branchAngle), y: Math.sin(branchAngle) };

        for (let j = 1; j <= count; j++) {
          const t2 = j * spacing / 100.0;
          const posOnBranch = branchLength * t2;

          const twigBaseX = baseX + dBranch.x * posOnBranch;
          const twigBaseY = baseY + dBranch.y * posOnBranch;

          let twigLength;
          if (reduction === 0) {
            twigLength = branchLength;
          } else {
            twigLength = branchLength * Math.pow(1 - reduction, j);
          }
          const twigWidth = twigLength * aspect;

          for (const sign2 of signs) {
            const twigAngle = branchAngle + sign2 * angleOffset;
            segments.push({
              bx: twigBaseX, by: twigBaseY,
              length: twigLength,
              width: twigWidth,
              angle: twigAngle,
              tipMode,
              tipScale,
              isTrunk: false
            });
          }
        }
      }
    }

    return segments;
  }

  function buildSnowflakeSegments(params) {
    const baseSegs = buildSingleTreeSegments(params);
    const arms = Math.max(3, params.armCount);
    const all = [];
    const twoPi = 2 * Math.PI;

    for (let k = 0; k < arms; k++) {
      const phi = twoPi * k / arms;
      const cosP = Math.cos(phi);
      const sinP = Math.sin(phi);

      for (const s of baseSegs) {
        const x = s.bx;
        const y = s.by;
        const rx = x * cosP - y * sinP;
        const ry = x * sinP + y * cosP;

        all.push({
          bx: rx,
          by: ry,
          length: s.length,
          width: s.width,
          angle: s.angle + phi,
          tipMode: s.tipMode,
          tipScale: s.tipScale,
          isTrunk: s.isTrunk
        });
      }
    }
    return all;
  }

  function buildTentHexFromEdge(p1, p2, dir, tipScale) {
    const dxB = p2[0] - p1[0];
    const dyB = p2[1] - p1[1];
    const b = Math.hypot(dxB, dyB);
    if (b <= 1e-9) return null;

    const baseDir = { x: dxB / b, y: dyB / b };
    const sqrt3 = Math.sqrt(3);
    const h = b / (2 * sqrt3);
    const midX = (p1[0] + p2[0]) * 0.5;
    const midY = (p1[1] + p2[1]) * 0.5;
    const apexX = midX + dir.x * h;
    const apexY = midY + dir.y * h;

    const A = p1;
    const B = p2;
    const C = [apexX, apexY];

    const v = { x: C[0] - A[0], y: C[1] - A[1] };
    const dot = v.x * baseDir.x + v.y * baseDir.y;
    const v_par = { x: baseDir.x * dot, y: baseDir.y * dot };
    const v_perp = { x: v.x - v_par.x, y: v.y - v_par.y };
    const C_ref = [ C[0] - 2 * v_perp.x, C[1] - 2 * v_perp.y ];

    const sLen = Math.hypot(C[0] - A[0], C[1] - A[1]);
    const t = { x: -dir.x * sLen, y: -dir.y * sLen };

    const A2 = [ A[0] + t.x, A[1] + t.y ];
    const B2 = [ B[0] + t.x, B[1] + t.y ];
    const C2 = [ C_ref[0] + t.x, C_ref[1] + t.y ];

    const pts = [A, B, C, A2, B2, C2].map(p => [p[0], p[1]]);

    let cx = 0, cy = 0;
    for (const [x, y] of pts) {
      cx += x; cy += y;
    }
    cx /= pts.length;
    cy /= pts.length;

    pts.sort((p, q) => {
      const angP = Math.atan2(p[1] - cy, p[0] - cx);
      const angQ = Math.atan2(q[1] - cy, q[0] - cx);
      return angP - angQ;
    });

    const hexPoly = pts.slice();
    hexPoly.push(hexPoly[0].slice());
    return scalePolygon(hexPoly, tipScale);
  }

  function buildRegularHexFromEdge(p1, p2, dir, tipScale) {
    const dxB = p2[0] - p1[0];
    const dyB = p2[1] - p1[1];
    const b = Math.hypot(dxB, dyB);
    if (b <= 1e-9) return null;

    const wdir = { x: dxB / b, y: dyB / b };
    const midX = (p1[0] + p2[0]) * 0.5;
    const midY = (p1[1] + p2[1]) * 0.5;
    const sqrt3 = Math.sqrt(3);

    const local = [
      [-b/2, 0],
      [ b/2, 0],
      [ b,   (sqrt3/2)*b ],
      [ b/2,  sqrt3*b    ],
      [-b/2,  sqrt3*b    ],
      [-b,   (sqrt3/2)*b ]
    ];

    function toWorld(X, Y) {
      return [
        midX + X * wdir.x + Y * dir.x,
        midY + X * wdir.y + Y * dir.y
      ];
    }

    const hexPoly = local.map(([X,Y]) => toWorld(X,Y));
    hexPoly.push(hexPoly[0].slice());
    return scalePolygon(hexPoly, tipScale);
  }

  function buildTrapHexFromEdge(p1, p2, dir, tipScale) {
    const dxB = p2[0] - p1[0];
    const dyB = p2[1] - p1[1];
    const b = Math.hypot(dxB, dyB);
    if (b <= 1e-9) return null;

    const wdir = { x: dxB / b, y: dyB / b };
    const midX = (p1[0] + p2[0]) * 0.5;
    const midY = (p1[1] + p2[1]) * 0.5;
    const sqrt3 = Math.sqrt(3);

    const h = (sqrt3 / 4) * b;
    const halfTop = b / 4;

    const local = [
      [ b/2,     0   ],
      [ halfTop, h   ],
      [-halfTop, h   ],
      [-b/2,     0   ],
      [-halfTop,-h   ],
      [ halfTop,-h   ]
    ];

    function toWorld(X, Y) {
      return [
        midX + X * wdir.x + Y * dir.x,
        midY + X * wdir.y + Y * dir.y
      ];
    }

    const hexTrapPoly = local.map(([X,Y]) => toWorld(X,Y));
    hexTrapPoly.push(hexTrapPoly[0].slice());
    return scalePolygon(hexTrapPoly, tipScale);
  }

  function segmentToPolys(seg, params) {
    const polys = [];
    const mainRect = makeRectFromBase(seg.bx, seg.by, seg.length, seg.width, seg.angle);

    const tipMode     = seg.tipMode;
    const tipScale    = (typeof seg.tipScale === 'number' && isFinite(seg.tipScale)) ? seg.tipScale : 1;
    const onlyTips    = !!params.tipOnly;
    const addBaseTips = !!params.tipAtCenter && !!seg.isTrunk;
    const showTrunk   = !!params.showTrunk;

    if (seg.isTrunk) {
      if (showTrunk) {
        polys.push(mainRect);
      }
    } else {
      if (!onlyTips) {
        polys.push(mainRect);
      }
    }

    if (tipMode === 0) return polys;

    const d = { x: Math.cos(seg.angle), y: Math.sin(seg.angle) };

    if (tipMode === 2) {
      function addYAt(baseX, baseY, mainAngle) {
        const capLength = seg.length * 0.3 * tipScale;
        const capWidth  = seg.width;
        const deltas = [Math.PI / 3, -Math.PI / 3];
        for (const delta of deltas) {
          const tipAngle = mainAngle + delta;
          polys.push(makeRectFromBase(baseX, baseY, capLength, capWidth, tipAngle));
        }
      }

      const tipBaseX = seg.bx + d.x * seg.length;
      const tipBaseY = seg.by + d.y * seg.length;
      addYAt(tipBaseX, tipBaseY, seg.angle);

      if (addBaseTips) {
        addYAt(seg.bx, seg.by, seg.angle + Math.PI);
      }

      return polys;
    }

    const p1_far  = mainRect[0];
    const p2_far  = mainRect[1];
    const p1_near = mainRect[3];
    const p2_near = mainRect[2];

    const dTop  = d;
    const dBase = { x: -d.x, y: -d.y };

    if (tipMode === 1) {
      const hexTop = buildTentHexFromEdge(p1_far,  p2_far,  dTop,  tipScale);
      if (hexTop) polys.push(hexTop);
      if (addBaseTips) {
        const hexBase = buildTentHexFromEdge(p1_near, p2_near, dBase, tipScale);
        if (hexBase) polys.push(hexBase);
      }
    } else if (tipMode === 3) {
      const hexTop = buildRegularHexFromEdge(p1_far,  p2_far,  dTop,  tipScale);
      if (hexTop) polys.push(hexTop);
      if (addBaseTips) {
        const hexBase = buildRegularHexFromEdge(p1_near, p2_near, dBase, tipScale);
        if (hexBase) polys.push(hexBase);
      }
    } else if (tipMode === 4) {
      const hexTop = buildTrapHexFromEdge(p1_far,  p2_far,  dTop,  tipScale);
      if (hexTop) polys.push(hexTop);
      if (addBaseTips) {
        const hexBase = buildTrapHexFromEdge(p1_near, p2_near, dBase, tipScale);
        if (hexBase) polys.push(hexBase);
      }
    }

    return polys;
  }

  // --- Punkt-beli tartalmazás, uniós kontúrokhoz (DXF-hez) ---

  function pointInPolygon(x, y, poly) {
    let inside = false;
    const n = poly.length;
    for (let i = 0, j = n - 1; i < n; j = i++) {
      const xi = poly[i][0], yi = poly[i][1];
      const xj = poly[j][0], yj = poly[j][1];

      const intersect = ((yi > y) !== (yj > y)) &&
                        (x < (xj - xi) * (y - yi) / (yj - yi + 1e-12) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  function buildLaserContoursExact(scaledPolys) {
    if (!scaledPolys || !scaledPolys.length) return [];

    const EPS = 1e-9;

    const polyInfos = scaledPolys.map(poly => {
      const unique = poly.slice(0, poly.length - 1);
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;
      for (const [x,y] of unique) {
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }
      return { poly, unique, minX, maxX, minY, maxY };
    });

    function pointInAnyPoly(x, y) {
      for (const info of polyInfos) {
        if (x < info.minX - 1e-6 || x > info.maxX + 1e-6 ||
            y < info.minY - 1e-6 || y > info.maxY + 1e-6) continue;
        if (pointInPolygon(x, y, info.poly)) return true;
      }
      return false;
    }

    const edges = [];
    for (let pi = 0; pi < scaledPolys.length; pi++) {
      const poly = scaledPolys[pi];
      const unique = poly.slice(0, poly.length - 1);
      const n = unique.length;
      if (n < 2) continue;
      for (let i = 0; i < n; i++) {
        const a = unique[i];
        const b = unique[(i + 1) % n];
        edges.push({
          ax: a[0], ay: a[1],
          bx: b[0], by: b[1],
          polyIndex: pi,
          splitTs: [0, 1]
        });
      }
    }

    function addParam(arr, t) {
      if (t < -EPS || t > 1 + EPS) return;
      t = Math.max(0, Math.min(1, t));
      for (let i = 0; i < arr.length; i++) {
        if (Math.abs(arr[i] - t) < 1e-6) return;
      }
      arr.push(t);
    }

    function intersectEdges(e1, e2) {
      const p = { x: e1.ax, y: e1.ay };
      const r = { x: e1.bx - e1.ax, y: e1.by - e1.ay };
      const q = { x: e2.ax, y: e2.ay };
      const s = { x: e2.bx - e2.ax, y: e2.by - e2.ay };

      const rxs = r.x * s.y - r.y * s.x;
      const qmp = { x: q.x - p.x, y: q.y - p.y };
      const qpxr = qmp.x * r.y - qmp.y * r.x;
      const rr = r.x * r.x + r.y * r.y;
      const ss = s.x * s.x + s.y * s.y;

      if (Math.abs(rxs) < 1e-9) {
        if (Math.abs(qpxr) > 1e-9) {
          return;
        }

        const t0 = ( (q.x - p.x) * r.x + (q.y - p.y) * r.y ) / rr;
        const t1 = ( (q.x + s.x - p.x) * r.x + (q.y + s.y - p.y) * r.y ) / rr;

        const tmin = Math.max(0, Math.min(t0, t1));
        const tmax = Math.min(1, Math.max(t0, t1));
        if (tmax < -1e-9 || tmin > 1 + 1e-9 || tmax - tmin < 1e-9) {
          return;
        }
        addParam(e1.splitTs, tmin);
        addParam(e1.splitTs, tmax);

        const u0 = ( (p.x - q.x) * s.x + (p.y - q.y) * s.y ) / ss;
        const u1 = ( (p.x + r.x - q.x) * s.x + (p.y + r.y - q.y) * s.y ) / ss;
        const umin = Math.max(0, Math.min(u0, u1));
        const umax = Math.min(1, Math.max(u0, u1));
        if (umax < -1e-9 || umin > 1 + 1e-9 || umax - umin < 1e-9) {
          return;
        }
        addParam(e2.splitTs, umin);
      } else {
        const t = (qmp.x * s.y - qmp.y * s.x) / rxs;
        const u = (qmp.x * r.y - qmp.y * r.x) / rxs;
        if (t >= -1e-9 && t <= 1 + 1e-9 && u >= -1e-9 && u <= 1 + 1e-9) {
          addParam(e1.splitTs, t);
          addParam(e2.splitTs, u);
        }
      }
    }

    for (let i = 0; i < edges.length; i++) {
      for (let j = i + 1; j < edges.length; j++) {
        intersectEdges(edges[i], edges[j]);
      }
    }

    const rawSegments = [];
    for (const e of edges) {
      const { ax, ay, bx, by, splitTs } = e;
      splitTs.sort((a, b) => a - b);
      for (let k = 0; k < splitTs.length - 1; k++) {
        const t0 = splitTs[k];
        const t1 = splitTs[k + 1];
        if (t1 - t0 < 1e-5) continue;
        const x0 = ax + (bx - ax) * t0;
        const y0 = ay + (by - ay) * t0;
        const x1 = ax + (bx - ax) * t1;
        const y1 = ay + (by - ay) * t1;
        rawSegments.push({ x0, y0, x1, y1 });
      }
    }

    const boundarySegments = [];
    for (const seg of rawSegments) {
      const dx = seg.x1 - seg.x0;
      const dy = seg.y1 - seg.y0;
      const len = Math.hypot(dx, dy);
      if (len < 1e-4) continue;
      const mx = 0.5 * (seg.x0 + seg.x1);
      const my = 0.5 * (seg.y0 + seg.y1);
      const nx = -dy / len;
      const ny =  dx / len;
      const off = 1e-3;

      const px1 = mx + nx * off;
      const py1 = my + ny * off;
      const px2 = mx - nx * off;
      const py2 = my - ny * off;

      const inside1 = pointInAnyPoly(px1, py1);
      const inside2 = pointInAnyPoly(px2, py2);

      if (inside1 !== inside2) {
        boundarySegments.push(seg);
      }
    }

    const pointKey = (x, y) => x.toFixed(4) + ',' + y.toFixed(4);

    const adjacency = new Map();

    function addEdgeAdj(x0, y0, x1, y1) {
      const k0 = pointKey(x0, y0);
      const k1 = pointKey(x1, y1);

      if (!adjacency.has(k0)) adjacency.set(k0, { pt: [x0, y0], neighbors: new Set() });
      if (!adjacency.has(k1)) adjacency.set(k1, { pt: [x1, y1], neighbors: new Set() });

      adjacency.get(k0).neighbors.add(k1);
      adjacency.get(k1).neighbors.add(k0);
    }

    for (const seg of boundarySegments) {
      addEdgeAdj(seg.x0, seg.y0, seg.x1, seg.y1);
    }

    const visited = new Set();
    const contours = [];

    for (const [key, node] of adjacency.entries()) {
      if (visited.has(key)) continue;

      const contour = [];
      let currentKey = key;
      let prevKey = null;

      while (currentKey && !visited.has(currentKey)) {
        visited.add(currentKey);
        const currentNode = adjacency.get(currentKey);
        contour.push(currentNode.pt);

        const neighbors = Array.from(currentNode.neighbors);
        let nextKey = null;

        for (const nk of neighbors) {
          if (nk !== prevKey) {
            nextKey = nk;
            if (!visited.has(nk)) break;
          }
        }

        prevKey = currentKey;
        currentKey = nextKey;

        if (!currentKey || currentKey === key) {
          break;
        }
      }

      if (contour.length >= 3) {
        if (contour[0] !== contour[contour.length - 1]) {
          contour.push(contour[0].slice());
        }
        contours.push(contour);
      }
    }

    return contours;
  }

  // --- Skálázott poligonok (nem unió!), JPG-hez ---

  function computePolysForCode(codeString) {
    const params = paramsFromCode(codeString);
    const segments = buildSnowflakeSegments(params);
    if (!segments.length) return null;

    let minX0 = Infinity, maxX0 = -Infinity;
    let minY0 = Infinity, maxY0 = -Infinity;

    for (const seg of segments) {
      const polys = segmentToPolys(seg, params);
      for (const poly of polys) {
        for (const [x,y] of poly) {
          if (x < minX0) minX0 = x;
          if (x > maxX0) maxX0 = x;
          if (y < minY0) minY0 = y;
          if (y > maxY0) maxY0 = y;
        }
      }
    }

    const width0  = maxX0 - minX0 || 1;
    const height0 = maxY0 - minY0 || 1;
    const size0   = Math.max(width0, height0) || 1;

    const scaleModelToMm = DXF_TARGET_SIZE / size0;
    const minRectMm  = Math.max(0, params.minRectMm || 0);
    const growSmall  = params.growSmallRects;
    const minWidthModel = minRectMm > 0 ? (minRectMm / scaleModelToMm) : 0;

    const adjustedSegments = [];
    for (const seg of segments) {
      if (minWidthModel <= 0) {
        adjustedSegments.push(seg);
      } else if (seg.width >= minWidthModel) {
        adjustedSegments.push(seg);
      } else {
        if (!growSmall) {
          continue;
        } else {
          adjustedSegments.push({ ...seg, width: minWidthModel });
        }
      }
    }

    if (!adjustedSegments.length) return null;

    const rects = [];
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;

    for (const seg of adjustedSegments) {
      const polys = segmentToPolys(seg, params);
      for (const poly of polys) {
        rects.push(poly);
        for (const [x,y] of poly) {
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
          if (y < minY) minY = y;
          if (y > maxY) maxY = y;
        }
      }
    }

    const width  = maxX - minX || 1;
    const height = maxY - minY || 1;
    const size   = Math.max(width, height) || 1;
    const scale  = DXF_TARGET_SIZE / size;

    const scaledPolys = rects.map(poly =>
      poly.map(([x,y]) => [ (x - minX) * scale, (y - minY) * scale ])
    );

    const widthMm  = width * scale;
    const heightMm = height * scale;

    return {
      polys: scaledPolys,
      minX: 0,
      maxX: widthMm,
      minY: 0,
      maxY: heightMm
    };
  }

  // --- Uniós kontúrok (DXF-hez) ---

  function computeContoursForCode(codeString) {
    const params = paramsFromCode(codeString);
    const segments = buildSnowflakeSegments(params);
    if (!segments.length) return null;

    let minX0 = Infinity, maxX0 = -Infinity;
    let minY0 = Infinity, maxY0 = -Infinity;

    for (const seg of segments) {
      const polys = segmentToPolys(seg, params);
      for (const poly of polys) {
        for (const [x,y] of poly) {
          if (x < minX0) minX0 = x;
          if (x > maxX0) maxX0 = x;
          if (y < minY0) minY0 = y;
          if (y > maxY0) maxY0 = y;
        }
      }
    }

    const width0  = maxX0 - minX0 || 1;
    const height0 = maxY0 - minY0 || 1;
    const size0   = Math.max(width0, height0) || 1;

    const scaleModelToMm = DXF_TARGET_SIZE / size0;
    const minRectMm  = Math.max(0, params.minRectMm || 0);
    const growSmall  = params.growSmallRects;
    const minWidthModel = minRectMm > 0 ? (minRectMm / scaleModelToMm) : 0;

    const adjustedSegments = [];
    for (const seg of segments) {
      if (minWidthModel <= 0) {
        adjustedSegments.push(seg);
      } else if (seg.width >= minWidthModel) {
        adjustedSegments.push(seg);
      } else {
        if (!growSmall) {
          continue;
        } else {
          adjustedSegments.push({ ...seg, width: minWidthModel });
        }
      }
    }

    if (!adjustedSegments.length) return null;

    const rects = [];
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;

    for (const seg of adjustedSegments) {
      const polys = segmentToPolys(seg, params);
      for (const poly of polys) {
        rects.push(poly);
        for (const [x,y] of poly) {
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
          if (y < minY) minY = y;
          if (y > maxY) maxY = y;
        }
      }
    }

    const width  = maxX - minX || 1;
    const height = maxY - minY || 1;
    const size   = Math.max(width, height) || 1;
    const scale  = DXF_TARGET_SIZE / size;

    const scaledPolys = rects.map(poly =>
      poly.map(([x,y]) => [ (x - minX) * scale, (y - minY) * scale ])
    );

    const contours = buildLaserContoursExact(scaledPolys);
    if (!contours.length) return null;

    let outerIndex = 0;
    let maxAbsArea = -1;
    for (let i = 0; i < contours.length; i++) {
      const contour = contours[i];
      const unique = contour.slice(0, contour.length - 1);
      if (unique.length < 3) continue;
      let area = 0;
      for (let j = 0, k = unique.length - 1; j < unique.length; k = j++) {
        const xi = unique[j][0], yi = unique[j][1];
        const xj = unique[k][0], yj = unique[k][1];
        area += (xj * yi - xi * yj);
      }
      area *= 0.5;
      const absArea = Math.abs(area);
      if (absArea > maxAbsArea) {
        maxAbsArea = absArea;
        outerIndex = i;
      }
    }

    const contoursWithFlags = contours.map((c, idx) => ({
      points: c,
      isOuter: idx === outerIndex
    }));

    return { contoursWithFlags };
  }

  function getContoursForCode(codeString) {
    if (geometryCache.has(codeString)) {
      return geometryCache.get(codeString);
    }
    const geom = computeContoursForCode(codeString);
    if (geom) {
      geometryCache.set(codeString, geom);
    }
    return geom;
  }

  function translateContour(contour, dx, dy) {
    const unique = contour.slice(0, contour.length - 1);
    const translated = unique.map(([x,y]) => [x + dx, y + dy]);
    translated.push(translated[0].slice());
    return translated;
  }

  // --- Mentés DXF + JSON ---
  function formatDateForFilename() {
    const d = new Date();
    const pad = (n) => String(n).padStart(2, '0');
    const y = d.getFullYear();
    const m = pad(d.getMonth() + 1);
    const day = pad(d.getDate());
    const hh = pad(d.getHours());
    const mm = pad(d.getMinutes());
    const ss = pad(d.getSeconds());
    return `${y}-${m}-${day}_${hh}-${mm}-${ss}`;
  }

  function downloadFile(content, mimeType, filename) {
    const blob = new Blob([content], { type: mimeType });
    downloadBlob(blob, filename);
  }

  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  async function exportCombinedDXFAndList() {
    if (!snowItems.length) {
      alert('Nincs hópehely a listában.');
      return;
    }

    const itemsForJson = snowItems.map(item => {
      let q = parseInt(item.qty, 10);
      if (!Number.isFinite(q) || q < 0) q = 0;
      return { code: item.code, qty: q };
    });

    const itemsForDxf = itemsForJson.filter(it => it.qty > 0);

    let totalPieces = 0;
    for (const it of itemsForDxf) {
      totalPieces += it.qty;
    }

    if (!totalPieces) {
      const tsEmpty = formatDateForFilename();
      const baseEmpty = `HAVAZO_${tsEmpty}`;
      const listObjEmpty = {
        version: 'HAVAZO-v8',
        generatedAt: new Date().toISOString(),
        items: itemsForJson
      };
      const jsonTextEmpty = JSON.stringify(listObjEmpty, null, 2);

      if (window.showDirectoryPicker) {
        try {
          const dirHandle = await window.showDirectoryPicker();
          const jsonHandle = await dirHandle.getFileHandle(baseEmpty + '.json', { create: true });
          const jsonWritable = await jsonHandle.createWritable();
          await jsonWritable.write(jsonTextEmpty);
          await jsonWritable.close();
        } catch (err) {
          console.error('JSON mentési hiba (v8, 0 darab):', err);
          downloadFile(jsonTextEmpty, 'application/json', baseEmpty + '.json');
        }
      } else {
        downloadFile(jsonTextEmpty, 'application/json', baseEmpty + '.json');
      }

      alert('Az összes darabszám 0, csak a listát mentettem el (DXF nem készült).');
      return;
    }

    const aggregatedContours = [];
    const cellSize = DXF_TARGET_SIZE + CELL_GAP;
    const cols = Math.ceil(Math.sqrt(totalPieces));
    let pieceIndex = 0;

    for (const entry of itemsForDxf) {
      const geom = getContoursForCode(entry.code);
      if (!geom) {
        console.warn('Nem sikerült geometriát generálni kódhoz:', entry.code);
        continue;
      }
      for (let n = 0; n < entry.qty; n++) {
        const row = Math.floor(pieceIndex / cols);
        const col = pieceIndex % cols;
        const dx = col * cellSize + CELL_MARGIN;
        const dy = row * cellSize + CELL_MARGIN;

        for (const c of geom.contoursWithFlags) {
          aggregatedContours.push({
            points: translateContour(c.points, dx, dy),
            isOuter: c.isOuter
          });
        }

        pieceIndex++;
      }
    }

    if (!aggregatedContours.length) {
      alert('Nem sikerült kontúrokat generálni a DXF-hez.');
      return;
    }

    let dxf = '';
    const NL = '\r\n';
    function add(code, value) {
      dxf += code + NL + value + NL;
    }

    add(0, 'SECTION');
    add(2, 'HEADER');
    add(0, 'ENDSEC');

    add(0, 'SECTION');
    add(2, 'ENTITIES');

    for (const contourObj of aggregatedContours) {
      const contour = contourObj.points;
      const unique = contour.slice(0, contour.length - 1);
      if (unique.length < 3) continue;

      add(0, 'LWPOLYLINE');
      add(8, '0');

      if (contourObj.isOuter) {
        add(62, 7); // fekete
      } else {
        add(62, 5); // kék
      }

      add(90, unique.length);
      add(70, 1);

      for (const [x, y] of unique) {
        add(10, x.toFixed(4));
        add(20, y.toFixed(4));
      }
    }

    add(0, 'ENDSEC');
    add(0, 'EOF');

    const ts = formatDateForFilename();
    const baseName = `HAVAZO_${ts}`;

    const listObj = {
      version: 'HAVAZO-v8',
      generatedAt: new Date().toISOString(),
      items: itemsForJson
    };
    const jsonText = JSON.stringify(listObj, null, 2);

    if (window.showDirectoryPicker) {
      try {
        const dirHandle = await window.showDirectoryPicker();

        const dxfBlob = new Blob([dxf], { type: 'application/dxf' });
        const dxfHandle = await dirHandle.getFileHandle(baseName + '.dxf', { create: true });
        const dxfWritable = await dxfHandle.createWritable();
        await dxfWritable.write(dxfBlob);
        await dxfWritable.close();

        const jsonHandle = await dirHandle.getFileHandle(baseName + '.json', { create: true });
        const jsonWritable = await jsonHandle.createWritable();
        await jsonWritable.write(jsonText);
        await jsonWritable.close();
      } catch (err) {
        console.error('DXF/JSON mentési hiba (v8):', err);
        downloadFile(dxf, 'application/dxf', baseName + '.dxf');
        downloadFile(jsonText, 'application/json', baseName + '.json');
      }
    } else {
      downloadFile(dxf, 'application/dxf', baseName + '.dxf');
      downloadFile(jsonText, 'application/json', baseName + '.json');
    }
  }

  // --- Lista betöltése JSON-ből ---
  function applyLoadedList(listObj) {
    if (!listObj || !Array.isArray(listObj.items)) {
      alert('Érvénytelen lista fájl.');
      return;
    }

    clearSnowItems();

    for (const it of listObj.items) {
      if (!it || typeof it.code !== 'string') continue;
      const code = it.code;
      let qty = parseInt(it.qty, 10);
      if (!Number.isFinite(qty) || qty < 0) qty = 0;

      let file = null;
      let name = '(virtuális hópehely)';
      let thumbUrl = null;

      const imgInfo = imagesByCode.get(code);
      if (imgInfo && imgInfo.file) {
        file = imgInfo.file;
        name = imgInfo.name || imgInfo.file.name;
        thumbUrl = URL.createObjectURL(imgInfo.file);
      }

      snowItems.push({
        file,
        name,
        code,
        qty,
        thumbUrl
      });
    }

    renderSnowList();
  }

  // --- JPG generálás hiányzó pelyhekhez ---

  function addJpegCommentToArrayBuffer(arrayBuffer, comment) {
    const bytes = new Uint8Array(arrayBuffer);
    if (bytes.length < 4 || bytes[0] !== 0xFF || bytes[1] !== 0xD8) {
      return new Blob([bytes], { type: 'image/jpeg' });
    }

    const encoder = new TextEncoder();
    const commentBytes = encoder.encode(comment);
    const len = commentBytes.length + 2;

    const newBytes = new Uint8Array(bytes.length + commentBytes.length + 4);
    let offset = 0;

    newBytes[offset++] = 0xFF;
    newBytes[offset++] = 0xD8;

    newBytes[offset++] = 0xFF;
    newBytes[offset++] = 0xFE;
    newBytes[offset++] = (len >> 8) & 0xFF;
    newBytes[offset++] = len & 0xFF;

    newBytes.set(commentBytes, offset);
    offset += commentBytes.length;

    newBytes.set(bytes.subarray(2), offset);

    return new Blob([newBytes], { type: 'image/jpeg' });
  }

  function createJpegBlobForCode(code) {
    const polyData = computePolysForCode(code);
    if (!polyData) return Promise.resolve(null);
    const { polys, minX, maxX, minY, maxY } = polyData;

    const canvas = document.createElement('canvas');
    canvas.width = 600;
    canvas.height = 640; // 600x640-es képméret
    const ctx = canvas.getContext('2d');

    // Teljes kép sötétkék háttérrel (nincs fehér sáv a JPG-ben)
    ctx.fillStyle = '#001633';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const width  = maxX - minX || 1;
    const height = maxY - minY || 1;

    const marginX   = 40;
    const topMargin = 40;
    const textSpace = 70;
    const drawWidth  = canvas.width - 2 * marginX;
    const drawHeight = canvas.height - topMargin - textSpace;

    const scale  = 0.95 * Math.min(drawWidth / width, drawHeight / height);
    const cx     = (minX + maxX) / 2;
    const cy     = (minY + maxY) / 2;
    const originX = canvas.width / 2;
    const originY = topMargin + drawHeight / 2;

    const fillColor   = '#bfe9ff';
    const strokeColor = fillColor; // kontúr = kitöltés színe

    ctx.lineJoin = 'round';
    ctx.lineCap  = 'round';
    ctx.lineWidth   = 1.2;
    ctx.fillStyle   = fillColor;
    ctx.strokeStyle = strokeColor;

    for (const poly of polys) {
      if (!poly || poly.length < 2) continue;
      ctx.beginPath();
      for (let i = 0; i < poly.length; i++) {
        const x = poly[i][0];
        const y = poly[i][1];
        const sx = originX + (x - cx) * scale;
        const sy = originY - (y - cy) * scale;
        if (i === 0) ctx.moveTo(sx, sy);
        else ctx.lineTo(sx, sy);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }

    ctx.fillStyle = '#ffffff';
    ctx.font = '16px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(code, canvas.width / 2, canvas.height - textSpace / 2);

    return new Promise((resolve) => {
      canvas.toBlob((blob) => {
        if (!blob) {
          resolve(null);
          return;
        }
        const reader = new FileReader();
        reader.onload = (e) => {
          const arr = e.target.result;
          const commentedBlob = addJpegCommentToArrayBuffer(arr, 'PEHELY-' + code);
          resolve(commentedBlob);
        };
        reader.readAsArrayBuffer(blob);
      }, 'image/jpeg', 0.92);
    });
  }

  async function generateMissingJpegsMain() {
    const missingItems = snowItems.filter(it => !it.file);
    if (!missingItems.length) {
      alert('Nincs hiányzó kép: minden betöltött kódhoz tartozik JPG.');
      return;
    }

    if (!window.showDirectoryPicker) {
      alert('A böngésző nem támogatja a közvetlen mappába írást, letöltésként kapod a hiányzó képeket.');
      for (const item of missingItems) {
        const code = item.code;
        const jpgBlob = await createJpegBlobForCode(code);
        if (!jpgBlob) {
          console.warn('Nem sikerült JPG-t generálni kódhoz:', code);
          continue;
        }
        const fileName = `PEHELY-${code}.jpg`;
        downloadBlob(jpgBlob, fileName);

        const fileObj = new File([jpgBlob], fileName, { type: 'image/jpeg' });
        if (item.thumbUrl) URL.revokeObjectURL(item.thumbUrl);
        item.file = fileObj;
        item.name = fileName;
        item.thumbUrl = URL.createObjectURL(fileObj);
        imagesByCode.set(code, { file: fileObj, name: fileName });
      }
      renderSnowList();
      return;
    }

    let dirHandle;
    try {
      dirHandle = await window.showDirectoryPicker();
    } catch (err) {
      console.error('Mappaválasztás megszakítva vagy hibás:', err);
      alert('A mappaválasztás megszakadt.');
      return;
    }

    for (const item of missingItems) {
      const code = item.code;
      try {
        const jpgBlob = await createJpegBlobForCode(code);
        if (!jpgBlob) {
          console.warn('Nem sikerült JPG-t generálni kódhoz:', code);
          continue;
        }
        const fileName = `PEHELY-${code}.jpg`;

        try {
          const fileHandle = await dirHandle.getFileHandle(fileName, { create: true });
          const writable = await fileHandle.createWritable();
          await writable.write(jpgBlob);
          await writable.close();
        } catch (errWrite) {
          console.error('Hiba a JPG mappába mentésekor, kód:', code, errWrite);
        }

        const fileObj = new File([jpgBlob], fileName, { type: 'image/jpeg' });
        if (item.thumbUrl) URL.revokeObjectURL(item.thumbUrl);
        item.file = fileObj;
        item.name = fileName;
        item.thumbUrl = URL.createObjectURL(fileObj);
        imagesByCode.set(code, { file: fileObj, name: fileName });
      } catch (err) {
        console.error('Nem sikerült JPG-t generálni kódhoz:', code, err);
      }
    }

    renderSnowList();
    alert('A hiányzó képek generálása és betöltése befejeződött.');
  }

  // --- Init ---
  window.addEventListener('load', () => {
    const folderInput        = document.getElementById('folderInput');
    const chooseFolderBtn    = document.getElementById('chooseFolderBtn');
    const saveListBtn        = document.getElementById('saveListBtn');
    const loadListBtn        = document.getElementById('loadListBtn');
    const loadListInput      = document.getElementById('loadListInput');
    const generateMissingBtn = document.getElementById('generateMissingBtn');
    const setAllQtyInput     = document.getElementById('setAllQtyInput');
    const setAllQtyBtn       = document.getElementById('setAllQtyBtn');

    chooseFolderBtn.addEventListener('click', () => {
      folderInput.value = '';
      folderInput.click();
    });

    folderInput.addEventListener('change', () => {
      handleFolderSelection(folderInput.files);
    });

    saveListBtn.addEventListener('click', () => {
      exportCombinedDXFAndList();
    });

    loadListBtn.addEventListener('click', () => {
      loadListInput.value = '';
      loadListInput.click();
    });

    loadListInput.addEventListener('change', (evt) => {
      const file = evt.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const text = e.target.result;
          const obj = JSON.parse(text);
          applyLoadedList(obj);
        } catch (err) {
          console.error('Hiba lista beolvasásakor:', err);
          alert('Nem sikerült beolvasni a listát.');
        }
      };
      reader.readAsText(file, 'utf-8');
    });

    generateMissingBtn.addEventListener('click', () => {
      generateMissingJpegsMain();
    });

    setAllQtyBtn.addEventListener('click', () => {
      let v = parseInt(setAllQtyInput.value, 10);
      if (!Number.isFinite(v) || v < 0) v = 0;
      setAllQtyInput.value = v;
      for (const item of snowItems) {
        item.qty = v;
      }
      renderSnowList();
    });
  });
</script>
</body>
</html>
