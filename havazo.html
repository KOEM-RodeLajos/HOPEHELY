<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rodé Lajos - HAVAZO</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont,
                   "Segoe UI", sans-serif;
    }
    body {
      margin: 0;
      padding: 0;
      background: #f2f4f8;
      color: #222;
    }
    h1 {
      font-size: 1.4rem;
      margin: 0 0 0.4rem 0;
    }
    .version {
      font-weight: normal;  /* verziószám ne legyen félkövér */
      margin-left: 0.2rem;
    }
    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem;
    }

    .top-bar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 0.6rem;
      margin-bottom: 0.7rem;
    }
    .folder-info {
      font-size: 0.9rem;
    }
    .folder-info strong {
      font-weight: 600;
    }

    button, .btn-link {
      padding: 0.35rem 0.7rem;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      transition: background 0.15s, box-shadow 0.15s, transform 0.05s;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
      white-space: nowrap;
    }
    button.secondary, .btn-secondary {
      background: #e9ecef;
      color: #222;
    }
    button.primary, .btn-primary {
      background: #0d6efd;
      color: #fff;
    }
    button:hover,
    .btn-link:hover {
      box-shadow: 0 1px 4px rgba(0,0,0,0.18);
    }
    button:active,
    .btn-link:active {
      transform: translateY(1px);
      box-shadow: none;
    }

    .cards-container {
      margin-top: 0.6rem;
      background: #fff;
      border-radius: 8px;
      padding: 0.7rem;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      min-height: 200px;
    }
    .cards-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 0.75rem;
    }

    .snowflake-card {
      background: #ffffff;
      border-radius: 10px;
      padding: 0.4rem 0.4rem 0.35rem;
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
      display: flex;
      flex-direction: column;
      align-items: center;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }
    .snowflake-card:hover {
      transform: translateY(-2px) scale(1.03);
      box-shadow: 0 4px 12px rgba(0,0,0,0.16);
    }

    .thumb-wrapper {
      width: 100%;
      background: #f2f2f2;
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .thumb-wrapper img {
      display: block;
      max-width: 100%;
      max-height: 100%;
      border-radius: 8px;
      background: transparent;
      aspect-ratio: 15 / 16;  /* a 600x640-hez közeli arány */
      object-fit: cover;
    }

    .qty-row {
      margin-top: 0.3rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
      font-size: 0.85rem;
    }
    .qty-row input[type="number"] {
      width: 3.5rem;
      padding: 0.15rem 0.2rem;
      text-align: center;
    }

    .bottom-bar {
      margin-top: 0.8rem;
      display: flex;
      flex-wrap: wrap;
      align-items: flex-end;
      justify-content: space-between;
      gap: 0.6rem;
    }
    .bottom-left {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }
    .bottom-right {
      display: flex;
      flex-direction: column;
      flex-wrap: nowrap;
      align-items: flex-end;
      justify-content: flex-end;
      gap: 0.35rem;
    }
    .layout-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-end;
      gap: 0.5rem;
      width: 100%;
    }
    .layout-row label {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      font-size: 0.82rem;
      color: #222;
    }
    .layout-row select {
      padding: 0.15rem 0.25rem;
      border-radius: 6px;
      border: 1px solid #cfd4da;
      background: #fff;
    }
    .layout-row input[type="number"] {
      width: 5.2rem;
      padding: 0.15rem 0.25rem;
      text-align: right;
      border-radius: 6px;
      border: 1px solid #cfd4da;
      background: #fff;
    }
    .action-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-end;
      gap: 0.4rem;
      width: 100%;
    }
    .action-row input[type="number"] {
      width: 4rem;
      padding: 0.15rem 0.2rem;
      text-align: center;
    }

    .note {
      font-size: 0.75rem;
      margin-top: 0.4rem;
      color: #555;
    }

    /* Előnézet overlay */
    #previewOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    #previewOverlay.active {
      display: flex;
    }
    .preview-content {
      background: #001633;
      color: #ffffff;
      border-radius: 10px;
      padding: 1rem 1.5rem 1.2rem;
      max-width: 90vw;
      max-height: 90vh;
      box-shadow: 0 8px 24px rgba(0,0,0,0.5);
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.6rem;
    }
    .preview-image-wrapper {
      max-width: 80vw;
      max-height: 70vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #previewImage {
      max-width: 100%;
      max-height: 100%;
      border-radius: 8px;
    }
    #previewCode {
      display: none;
      font-size: 0.95rem;
      letter-spacing: 0.04em;
      text-align: center;
      word-break: break-all;
    }
    #previewCloseBtn {
      position: absolute;
      top: 0.25rem;
      right: 0.6rem;
      background: transparent;
      border: none;
      color: #ffffff;
      font-size: 1.3rem;
      cursor: pointer;
    }

    @media (max-width: 700px) {
      .bottom-bar {
        flex-direction: column;
        align-items: stretch;
      }
      .bottom-right {
        align-items: stretch;
      }
      .layout-row, .action-row {
        justify-content: flex-start;
      }
    }
    /* Kártya státusz: a JPG megléte a bélyegképen látszik (kék vs bordó), a keret semleges. */

    .algo-row textarea {
      width: 100%;
      resize: vertical;
      min-height: 44px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.18);
      color: rgba(255,255,255,0.92);
      box-sizing: border-box;
    }
</style>
</head>
<body>
<div class="page">
  <h1>Rodé Lajos - HAVAZO <span id="appVersion" class="version">v?</span></h1>

  <div class="top-bar">
    <div class="folder-info">
      Aktuális mappa:
      <strong id="currentFolderName">Letöltések (alapértelmezett – válassz mappát)</strong>
    </div>
    <button id="chooseFolderBtn" class="secondary">Mappa kijelölése</button>
      <input id="folderFileInput" type="file" accept="image/jpeg" multiple webkitdirectory directory style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0">
      <input id="jsonFileInput" type="file" accept="application/json,.json" style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0">

  </div>

  <div class="cards-container">
    <div id="cardsGrid" class="cards-grid">
      <!-- kártyák ide kerülnek -->
    </div>
    <div id="emptyMessage" class="note">
      Válassz munkamappát a hópelyhek betöltéséhez.
    </div>
  </div>

  <!-- ÚJ összesítő sorok -->
  <div id="summaryInfo" class="note">
    A mappában szereplő összes típus:
    <span id="summaryAllTypes">0</span> db<br>
    Kiválasztott típusok:
    <span id="summarySelectedTypes">0</span> db<br>
    Mentendő összesen:
    <span id="summaryTotalPieces">0</span> db
  </div>

  <div class="bottom-bar">
    <div class="bottom-left">
      <a href="pehely.html" id="gotoPehelyLink" class="btn-link btn-secondary">GENERÁTOR</a>
    </div>
    <div class="bottom-right">
      <!-- Kirakási beállítások (a Lista betöltése gomb fölötti sorban) -->
      <div class="layout-row">
        <label>
          Elrendezés:
          <select id="layoutModeSelect">
            <option value="grid" selected>Rács</option>
            <option value="shelf">Polc</option>
            <option value="circle">Kör</option>
          </select>
        </label>
        <label>
          Szélesség:
          <input id="sheetWidthInput" type="number" min="1" step="1" value="600">
          mm
        </label>
        <label>
          Magasság:
          <input id="sheetHeightInput" type="number" min="1" step="1" value="400">
          mm
        </label>
        <label>
          Köz:
          <input id="shapeGapInput" type="number" min="0" step="0.1" value="2">
          mm
        </label>
      
        <label>
          DXF alg.:
          <select id="dxfAlgoSelect">
            <option value="all">MIND</option>
            <option value="A">A</option>
            <option value="B" selected>B</option>
          </select>
        </label>
</div>

      <div class="algo-row">
        <label style="width:100%;">
          Algoritmus összefoglaló:
          <textarea id="dxfAlgoDesc" rows="2" readonly></textarea>
        </label>
      </div>

      <div class="action-row">
        <button id="loadListBtn" class="secondary">Lista betöltése</button>
        <button id="generateMissingBtn" class="secondary">Hiányzó képek generálása</button>

        <div style="display:flex;align-items:center;gap:0.25rem;">
          <input id="bulkQtyInput" type="number" min="0" step="1" value="1">
          <span>db</span>
        </div>
        <button id="bulkApplyBtn" class="secondary">mind</button>
        <button id="testBtn" class="secondary">TESZT</button>
        <button id="saveAllBtn" class="primary">MENTÉS</button>
      </div>
      <div id="saveProgressArea" style="display:none; align-items:center; gap:0.5rem; margin-top:0.5rem;">
        <progress id="saveProgress" value="0" max="1" style="width:260px; height:14px;"></progress>
        <span id="saveProgressCount" class="code">0/0</span>
        <span id="saveProgressStatus" style="opacity:0.85; font-size:12px;"></span>
      </div>
    </div>
  </div>
</div>

<!-- Nagy előnézet overlay -->
<div id="previewOverlay">
  <div class="preview-content" id="previewContent">
    <button id="previewCloseBtn" title="Bezárás">✕</button>
    <div class="preview-image-wrapper">
      <img id="previewImage" src="" alt="Hópelyhes előnézet">
    </div>
    <div id="previewCode"></div>
  </div>
</div>

<script src="./pehely-core.js"></script>

<script>

  // ====== PehelyCore (közös algoritmus modul) ======
  const PC = window.PehelyCore;
  if (!PC) {
    alert('Hiányzik a PehelyCore (pehely-core.js). Tedd a HTML-ek mellé ugyanabba a mappába. Ha csak verziószámos (pl. pehely-core_v80.js) van, nevezd át pehely-core.js-re.');
    throw new Error('PehelyCore hiányzik');
  }
  const {
    paramsFromCode,
    buildSnowflakeSegments,
    // FONTOS: ne vegyük fel computeContoursForCode néven, mert lent ugyanilyen
    // néven van egy helyi (cache-elő) wrapperünk. Ha mindkettő ugyanaz a név,
    // az szintaktikai hibát okoz, és emiatt SEMMILYEN gomb nem fog működni.
    computeContoursForCode: coreComputeContoursForCode,
    computeContoursForParams,
    computePolysForCode,
    createJpegBlobForCode,
    parseCodeFromJpegArrayBuffer,
    addJpegCommentToArrayBuffer
  } = PC;

  // ====== Általános segédek ======
  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // ====== Save manager: mappa ha lehet, különben Letöltések ======
  const saveManager = (() => {
    // mode: 'unknown' | 'dir' | 'download'
    let mode = 'unknown';
    let outDirHandle = null;

    function canUseDir() {
      return !!window.showDirectoryPicker && !!window.isSecureContext;
    }

    async function ensureOutDir() {
      if (mode === 'download') return null;
      if (outDirHandle) return outDirHandle;

      if (!canUseDir()) {
        mode = 'download';
        return null;
      }

      try {
        outDirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
        if (outDirHandle && outDirHandle.queryPermission) {
          let p = await outDirHandle.queryPermission({ mode: 'readwrite' });
          if (p !== 'granted' && outDirHandle.requestPermission) {
            p = await outDirHandle.requestPermission({ mode: 'readwrite' });
          }
          if (p !== 'granted') {
            outDirHandle = null;
            mode = 'download';
            return null;
          }
        }
        mode = outDirHandle ? 'dir' : 'download';
        return outDirHandle;
      } catch (e) {
        console.warn('Kimeneti mappa kiválasztása megszakítva vagy hiba:', e);
        mode = 'download';
        outDirHandle = null;
        return null;
      }
    }

    async function writeToDir(dirHandle, filename, blob) {
      const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(blob);
      await writable.close();
    }

    async function saveMany(files) {
      const dir = await ensureOutDir();
      if (dir) {
        for (const f of files) {
          try {
            await writeToDir(dir, f.name, f.blob);
          } catch (e) {
            console.warn('Nem sikerült mappába menteni, letöltés lesz:', e);
            downloadBlob(f.blob, f.name);
          }
        }
        return { mode: 'dir' };
      } else {
        for (const f of files) downloadBlob(f.blob, f.name);
        return { mode: 'download' };
      }
    }

    function setOutDirHandle(dirHandleOrNull) {
      outDirHandle = dirHandleOrNull || null;
      mode = outDirHandle ? 'dir' : 'unknown';
    }

    function reset() {
      outDirHandle = null;
      mode = 'unknown';
    }

    return { saveMany, ensureOutDir, setOutDirHandle, reset };
  })();



  async function saveWithPickerOrDownload(suggestedName, mimeType, content) {
    const blob = (content instanceof Blob) ? content : new Blob([content], { type: mimeType });
    await saveManager.saveMany([{ name: suggestedName, blob }]);
  }

  function formatTimestampForName(date) {
    const pad = (n) => String(n).padStart(2, '0');
    const y = date.getFullYear();
    const m = pad(date.getMonth() + 1);
    const d = pad(date.getDate());
    const hh = pad(date.getHours());
    const mm = pad(date.getMinutes());
    const ss = pad(date.getSeconds());
    return `${y}-${m}-${d}_${hh}-${mm}-${ss}`;
  }

  // ====== PEHELY-kód kezelése + geometria (kompatibilis a generátorral) ======

  const DXF_TARGET_SIZE = PC.DXF_TARGET_SIZE; // mm (core-ból)
  const geometryCache = new Map(); // code -> { contoursWithFlags }

  // [KISZERVEZVE pehely-core.js-be] paramsFromCode


  // [KISZERVEZVE pehely-core.js-be] makeRectFromBase


  // [KISZERVEZVE pehely-core.js-be] scalePolygon


  // [KISZERVEZVE pehely-core.js-be] buildSingleTreeSegments


  // [KISZERVEZVE pehely-core.js-be] buildSnowflakeSegments


  // [KISZERVEZVE pehely-core.js-be] buildTentHexFromEdge


  // [KISZERVEZVE pehely-core.js-be] buildRegularHexFromEdge


  // [KISZERVEZVE pehely-core.js-be] buildTrapHexFromEdge


  // [KISZERVEZVE pehely-core.js-be] segmentToPolys


  // [KISZERVEZVE pehely-core.js-be] pointInPolygon


  // [KISZERVEZVE pehely-core.js-be] buildLaserContoursExact


  function computeContoursForCode(codeString, algo = 'A', paramsOverride = null) {
    const params = paramsOverride || paramsFromCode(codeString);
    const runoffKey = (params && params.runoff) ? params.runoff : 'Oo.';
        const cacheKey = `${algo}|${codeString}|RUNOFF:${runoffKey}`;
    if (geometryCache.has(cacheKey)) return geometryCache.get(cacheKey);

        const result = computeContoursForParams(params, algo);
    geometryCache.set(cacheKey, result);
    return result;
  }

  // [KISZERVEZVE pehely-core.js-be] computePolysForCode


  // [KISZERVEZVE pehely-core.js-be] addJpegCommentToArrayBuffer


  // [KISZERVEZVE pehely-core.js-be] createJpegBlobForCode


  // [KISZERVEZVE pehely-core.js-be] parseCodeFromJpegArrayBuffer


  async function readCodeFromJpegFileHandle(fileHandle) {
    const file = await fileHandle.getFile();
    const arrayBuffer = await file.arrayBuffer();
    const raw = parseCodeFromJpegArrayBuffer(arrayBuffer);
    if (!raw) return null;
    return PC.upgradeCodeToCurrent(raw);
  }
  async function readCodeFromJpegFile(file) {
    try {
      const arrayBuffer = await file.arrayBuffer();
      const raw = parseCodeFromJpegArrayBuffer(arrayBuffer);
      if (!raw) return null;
      return PC.upgradeCodeToCurrent(raw);
    } catch (e) {
      console.warn('Nem sikerült a JPG beolvasása:', e);
      return null;
    }
  }


  // ====== HAVAZO adatszerkezetek ======

  let currentDirectoryHandle = null;
  let currentSelectedFiles = null; // File[] fallback (ha nincs / nem működik showDirectoryPicker)

  const cardsGrid = document.getElementById('cardsGrid');
  const emptyMessage = document.getElementById('emptyMessage');
  const currentFolderNameEl = document.getElementById('currentFolderName');

  let items = [];                // { code, fileHandle|null, imgURL, quantity, isVirtual, cardElem, qtyInput }
  const itemsByCode = new Map(); // code -> item
  const quantitiesFromJson = new Map(); // code -> count (0 is megőrződik)

  // Summary elemek
  const summaryAllTypesEl      = document.getElementById('summaryAllTypes');
  const summarySelectedTypesEl = document.getElementById('summarySelectedTypes');
  const summaryTotalPiecesEl   = document.getElementById('summaryTotalPieces');

  function updateSummaryCounts() {
    // összes típus a mappában: olyan itemek, amelyekhez van valódi JPG (nem virtuális)
    const totalFolderTypes = items.filter(it => !it.isVirtual).length;

    // kiválasztott típusok: item.quantity > 0
    let selectedTypes = 0;
    let totalPieces = 0;
    for (const it of items) {
      const q = Number.isFinite(it.quantity) ? it.quantity : 0;
      if (q > 0) selectedTypes++;
      totalPieces += Math.max(0, q);
    }

    summaryAllTypesEl.textContent      = totalFolderTypes.toString();
    summarySelectedTypesEl.textContent = selectedTypes.toString();
    summaryTotalPiecesEl.textContent   = totalPieces.toString();
  }

  // ====== Kártyák + overlay ======

  const previewOverlay = document.getElementById('previewOverlay');
  const previewImage   = document.getElementById('previewImage');
  const previewCodeEl  = document.getElementById('previewCode');
  const previewCloseBtn= document.getElementById('previewCloseBtn');
  const previewContent = document.getElementById('previewContent');

  function openPreviewForItem(item) {
    if (!item || !item.imgURL) return;
    previewImage.src = item.imgURL;

    // A felugróban csak a kód maradjon: ha több sor van és valamelyik sorban szerepel a "PEHELY" szó, azt a sort kihagyjuk.
    const raw = (item && item.code != null) ? String(item.code) : '';
    const lines = raw.split(/\r?\n/);
    const filtered = lines.filter(l => !/\bPEHELY\b/i.test(l));
    let display = filtered.length ? filtered.join('\n') : raw;

    // Fallback: ha egyetlen sor volt "PEHELY-" előtaggal, akkor csak az előtagot vágjuk le.
    if (!display.trim() && raw) {
      display = raw.replace(/^\s*PEHELY-?/i, '').trim();
    }
    // v79: a kód csak a képbe égetve jelenik meg (previewCode rejtve)
    previewCodeEl.textContent = '';
    previewOverlay.classList.add('active');
  }

  function closePreview() {
    previewOverlay.classList.remove('active');
  }

  previewCloseBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    closePreview();
  });
  previewOverlay.addEventListener('click', () => {
    closePreview();
  });
  previewContent.addEventListener('click', (e) => {
    e.stopPropagation();
  });
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') closePreview();
  });

  function createCardForItem(item) {
    const card = document.createElement('div');
    card.className = 'snowflake-card ' + (item.isVirtual ? 'virtual' : 'has-jpg');

    const thumbWrap = document.createElement('div');
    thumbWrap.className = 'thumb-wrapper';

    const img = document.createElement('img');
    img.src = item.imgURL;
    img.alt = 'Hópehely';

    thumbWrap.appendChild(img);
    card.appendChild(thumbWrap);

    const qtyRow = document.createElement('div');
    qtyRow.className = 'qty-row';

    const qtyInput = document.createElement('input');
    qtyInput.type = 'number';
    qtyInput.min = '0';
    qtyInput.step = '1';
    qtyInput.value = item.quantity.toString();

    const dbSpan = document.createElement('span');
    dbSpan.textContent = 'db';

    qtyRow.appendChild(qtyInput);
    qtyRow.appendChild(dbSpan);
    card.appendChild(qtyRow);

    qtyInput.addEventListener('click', (e) => {
      e.stopPropagation();
    });
    qtyInput.addEventListener('change', () => {
      let v = parseInt(qtyInput.value, 10);
      if (!Number.isFinite(v) || v < 0) v = 0;
      qtyInput.value = v.toString();
      item.quantity = v;
      quantitiesFromJson.set(item.code, v);
      updateSummaryCounts();
    });

    card.addEventListener('click', () => {
      openPreviewForItem(item);
    });

    item.cardElem = card;
    item.qtyInput = qtyInput;
    updateCardClasses(item);
    return card;
  }

  
  function updateCardClasses(item) {
    if (!item || !item.cardElem) return;
    item.cardElem.classList.toggle('virtual', !!item.isVirtual);
    item.cardElem.classList.toggle('has-jpg', !item.isVirtual);
  }

function refreshCardsGrid() {
    cardsGrid.innerHTML = '';
    if (!items.length) {
      emptyMessage.style.display = 'block';
      updateSummaryCounts();
      return;
    }
    emptyMessage.style.display = 'none';
    for (const item of items) {
      const card = createCardForItem(item);
      cardsGrid.appendChild(card);
    }
    updateSummaryCounts();
  }

  // ====== Mappa beolvasása ======

  async function pickFolderAndScan() {
    const folderInput = document.getElementById('folderFileInput');

    if (window.showDirectoryPicker) {
      try {
        const handle = await window.showDirectoryPicker();
        currentDirectoryHandle = handle;
        saveManager.setOutDirHandle(handle);
        currentSelectedFiles = null;
        currentFolderNameEl.textContent = handle.name;
        await scanSources();
        return;
      } catch (e) {
        console.warn('Mappa kijelölése sikertelen (fallback következik):', e);
      }
    }

    if (folderInput) {
      folderInput.value = '';
      folderInput.click();
      return;
    }

    alert('A böngésződben nem érhető el a mappa kiválasztása.');
  }

  
  function cleanupObjectUrls() {
    try {
      for (const it of items) {
        if (it && typeof it.imgURL === 'string' && it.imgURL.startsWith('blob:')) {
          URL.revokeObjectURL(it.imgURL);
        }
      }
    } catch (e) {
      // no-op
    }
  }

  async function scanSelectedFiles() {
    items = [];
    itemsByCode.clear();
    cardsGrid.innerHTML = '';
    emptyMessage.style.display = 'block';

    if (!currentSelectedFiles || !currentSelectedFiles.length) {
      // Nincs kijelölt JPG; ha van JSON-lista, attól még készítünk virtuális kártyákat.
    }

    try {
      for (const file of (currentSelectedFiles || [])) {
        if (!file || !(file.name || '').toLowerCase().endsWith('.jpg')) continue;

        const code = await readCodeFromJpegFile(file);
        if (!code) continue;

        if (itemsByCode.has(code)) continue;

        const url = URL.createObjectURL(file);
        const qty = quantitiesFromJson.has(code) ? quantitiesFromJson.get(code) : 0;

        const item = {
          code,
          fileHandle: null,
          fileName: file.name,
          imgURL: url,
          quantity: qty,
          isVirtual: false,
          cardElem: null,
          qtyInput: null
        };
        items.push(item);
        itemsByCode.set(code, item);
      }
    } catch (e) {
      console.error('Hiba a fájlok beolvasása közben:', e);
    }

    // Régi lista alapján hiányzók virtuális generálása (ugyanúgy, mint mappánál)
    const codesInJson = Array.from(quantitiesFromJson.keys());
    for (const code of codesInJson) {
      const upgradedCode = (() => { try { return PC.upgradeCodeToCurrent(code); } catch { return code; } })();
      if (!itemsByCode.has(upgradedCode)) {
        try {
          const blob = await createJpegBlobForCode(upgradedCode, 'bordo');
          if (!blob) continue;
          const url = URL.createObjectURL(blob);
          const qty = quantitiesFromJson.get(upgradedCode) || 0;
          const item = {
            code: upgradedCode,
            fileHandle: null,
            fileName: null,
            imgURL: url,
            quantity: qty,
            isVirtual: true,
            cardElem: null,
            qtyInput: null
          };
          items.push(item);
          itemsByCode.set(code, item);
        } catch (e) {
          console.error('Virtuális kép generálási hiba:', e);
        }
      }
    }

    refreshCardsGrid();
  }

  
  async function suggestWorkFolderIfMissing() {
    // Weben nem tudjuk automatikusan kinyerni a JSON szülőmappáját.
    // Ha nincs munkamappa, felajánljuk, hogy a felhasználó válassza ki (célszerűen ugyanazt a mappát, ahol a JSON van).
    if (currentDirectoryHandle) return;
    if (!window.showDirectoryPicker || !window.isSecureContext) return;

    const ok = confirm('Nincs munkamappa kijelölve. Szeretnéd most kiválasztani a mappát (célszerűen azt, ahol a JSON is van), hogy a JPG-ket oda tudjuk menteni?');
    if (!ok) return;

    try {
      const handle = await window.showDirectoryPicker({ mode: 'readwrite' });
      currentDirectoryHandle = handle;
      currentSelectedFiles = null;
      currentFolderNameEl.textContent = handle.name;
      saveManager.setOutDirHandle(handle);
      await scanSources();
    } catch (e) {
      console.warn('Mappa kijelölése megszakítva vagy hiba:', e);
    }
  }

async function scanSources() {
    cleanupObjectUrls();
    if (currentDirectoryHandle) return scanCurrentFolder();
    return scanSelectedFiles();
  }

  function applyQuantitiesFromJsonData(data) {
    quantitiesFromJson.clear();
    if (data && Array.isArray(data.items)) {
      for (const it of data.items) {
        if (!it || typeof it.code !== 'string') continue;
        const count = Number.isFinite(it.count) ? it.count : 0;
        try {
          const upgraded = PC.upgradeCodeToCurrent(it.code);
          quantitiesFromJson.set(upgraded, count);
        } catch (e) {
          // ha teljesen rossz kód lenne, tartsuk meg eredetiben
          quantitiesFromJson.set(it.code, count);
        }
      }
    }
  }

  function inferSelectedFolderName(files) {
    // Fallback mappa-kijelölésnél (webkitdirectory) a böngésző nem ad "mappa handle"-t.
    // Sok esetben elérhető a webkitRelativePath, pl. "MappaAlja/valami.jpg".
    // Ebből (ha egyértelmű) ki tudjuk írni a mappa nevét az UI-ban.
    try {
      const roots = new Set();
      for (const f of (files || [])) {
        const rel = (f && f.webkitRelativePath) ? String(f.webkitRelativePath) : '';
        if (!rel) continue;
        const root = rel.split('/')[0];
        if (root) roots.add(root);
        if (roots.size > 1) break;
      }
      if (roots.size === 1) return Array.from(roots)[0];
    } catch (_) {}
    return null;
  }

  function onFolderFilesSelected(evt) {
    const files = Array.from(evt.target.files || []).filter(f => (f.name || '').toLowerCase().endsWith('.jpg'));
    currentSelectedFiles = files;
    currentDirectoryHandle = null;
    saveManager.setOutDirHandle(null);

    const folderName = inferSelectedFolderName(files);
    if (folderName) {
      currentFolderNameEl.textContent = `${folderName} (${files.length})`;
    } else {
      currentFolderNameEl.textContent = files.length ? `Kijelölt fájlok (${files.length})` : '—';
    }

    scanSources();
  }


  function onJsonFileSelected(evt) {
    const file = (evt.target.files && evt.target.files[0]) ? evt.target.files[0] : null;
    if (!file) return;
    file.text().then(text => {
      const data = JSON.parse(text);
      applyQuantitiesFromJsonData(data);
      scanSources().then(() => suggestWorkFolderIfMissing());
    }).catch(e => {
      console.error('JSON beolvasási hiba:', e);
      alert('Nem sikerült beolvasni a JSON-t.');
    });
  }
async function scanCurrentFolder() {
    cleanupObjectUrls();
    items = [];
    itemsByCode.clear();
    cardsGrid.innerHTML = '';
    emptyMessage.style.display = 'block';

    if (!currentDirectoryHandle) {
      updateSummaryCounts();
      return;
    }

    try {
      for await (const entry of currentDirectoryHandle.values()) {
        if (entry.kind === 'file' &&
            entry.name.toLowerCase().endsWith('.jpg')) {

          const code = await readCodeFromJpegFileHandle(entry);
          if (!code) continue;

          if (itemsByCode.has(code)) continue;

          const file = await entry.getFile();
          const url = URL.createObjectURL(file);
          const qty = quantitiesFromJson.has(code) ? quantitiesFromJson.get(code) : 1;

          const item = {
            code: upgradedCode,
            fileHandle: entry,
            imgURL: url,
            quantity: qty,
            isVirtual: false,
            cardElem: null,
            qtyInput: null
          };
          items.push(item);
          itemsByCode.set(code, item);
        }
      }
    } catch (e) {
      console.error('Hiba a mappa olvasása közben:', e);
    }

    for (const [code, qty] of quantitiesFromJson.entries()) {
      if (!itemsByCode.has(code)) {
        try {
          const blob = await createJpegBlobForCode(code, 'bordo');
          if (!blob) continue;
          const url = URL.createObjectURL(blob);
          const item = {
            code: upgradedCode,
            fileHandle: null,
            imgURL: url,
            quantity: qty,
            isVirtual: true,
            cardElem: null,
            qtyInput: null
          };
          items.push(item);
          itemsByCode.set(code, item);
        } catch (e) {
          console.error('Virtuális kép generálási hiba:', e);
        }
      }
    }

    refreshCardsGrid();
  }

  // ====== Lista betöltése (JSON) ======

  async function loadListFromJson() {
    const jsonInput = document.getElementById('jsonFileInput');

    // Preferált: File System Access API (Chrome/Edge) – csak biztonságos kontextusban
    // (file:// alatt gyakran létezik a függvény, de a hívás nem engedélyezett).
    if (window.showOpenFilePicker && window.isSecureContext) {
      try {
        const [handle] = await window.showOpenFilePicker({
          types: [{
            description: 'HAVAZO lista (JSON)',
            accept: { 'application/json': ['.json'] }
          }]
        });
        const file = await handle.getFile();
        const text = await file.text();
        const data = JSON.parse(text);

        applyQuantitiesFromJsonData(data);
        await scanSources();
        return;
      } catch (e) {
        // Ha a felhasználó megszakítja, ne nyissunk másik picker-t.
        if (e && e.name === 'AbortError') return;

        // Egyéb hiba esetén (pl. jogosultság/korlátozás) menjünk fallback-re.
        console.warn('Lista betöltése showOpenFilePicker-rel nem sikerült, fallback lesz:', e);
      }
    }

    // Fallback: sima file input (mindenhol működik, Letöltésekből is)
    if (jsonInput) {
      jsonInput.value = '';
      jsonInput.click();
      return;
    }

    alert('A böngésződben nem érhető el a JSON betöltése.');
  }


  // ====== Hiányzó képek generálása ======

  async function generateMissingImages() {
    const codesSet = new Set();
    for (const [code] of quantitiesFromJson.entries()) codesSet.add(code);
    for (const item of items) codesSet.add(item.code);

    if (!codesSet.size) {
      alert('Nincs ismert hópehely-kód, amit generálni lehetne.');
      return;
    }

    const missingCodes = [];
    for (const code of codesSet) {
      const item = itemsByCode.get(code);
      if (!item || item.isVirtual) missingCodes.push(code);
    }

    if (!missingCodes.length) {
      alert('Nincs hiányzó kép: minden kódhoz van már betöltött kép.');
      return;
    }

    const files = [];
    const blobsByCode = new Map();

    for (const code of missingCodes) {
      try {
        const blob = await createJpegBlobForCode(code);
        if (!blob) continue;
        blobsByCode.set(code, blob);
        files.push({ name: `PEHELY-${code}.jpg`, blob });
      } catch (e) {
        console.error('Hiba a kép generálásakor:', e);
      }
    }

    if (!files.length) {
      alert('Nem sikerült képet generálni a hiányzókhoz.');
      return;
    }

    await saveManager.saveMany(files);

    for (const [code, blob] of blobsByCode.entries()) {
      const item = itemsByCode.get(code);
      if (!item) continue;

      try { if (item.imgURL) URL.revokeObjectURL(item.imgURL); } catch (_) {}
      item.imgURL = URL.createObjectURL(blob);
      item.isVirtual = false;

      if (item.cardElem) {
        const img = item.cardElem.querySelector('img');
        if (img) img.src = item.imgURL;
        updateCardClasses(item);
      }
    }

    alert('A hiányzó képek elkészültek. (Ha Letöltésekbe mentődtek, másold át őket a munkamappába, majd olvasd be újra a mappát.)');
  }

  // ====== Minden mennyiséget azonosra állító gomb ======

  function applyBulkQuantity() {
    let v = parseInt(document.getElementById('bulkQtyInput').value, 10);
    if (!Number.isFinite(v) || v < 0) v = 0;
    document.getElementById('bulkQtyInput').value = v.toString();

    for (const item of items) {
      item.quantity = v;
      if (item.qtyInput) item.qtyInput.value = v.toString();
      quantitiesFromJson.set(item.code, v);
    }
    updateSummaryCounts();
  }

  // ====== DXF + JSON mentés (MENTÉS gomb) ======

  function translateContour(contour, dx, dy) {
    const unique = contour.slice(0, contour.length - 1);
    const translated = unique.map(([x,y]) => [x + dx, y + dy]);
    translated.push(translated[0].slice());
    return translated;
  }


  // ====== Mentés állapotjelző ======
  const saveProgressArea = document.getElementById('saveProgressArea');
  const saveProgressEl = document.getElementById('saveProgress');
  const saveProgressCountEl = document.getElementById('saveProgressCount');
  const saveProgressStatusEl = document.getElementById('saveProgressStatus');

  const saveUiTick = () => new Promise(resolve => requestAnimationFrame(() => resolve()));

  function showSaveProgress(value, max, status) {
    if (!saveProgressArea || !saveProgressEl || !saveProgressCountEl) return;
    const m = Math.max(1, Number.isFinite(max) ? max : 1);
    const v = Math.max(0, Math.min(m, Number.isFinite(value) ? value : 0));
    saveProgressArea.style.display = 'flex';
    saveProgressEl.max = m;
    saveProgressEl.value = v;
    saveProgressCountEl.textContent = `${v}/${m}`;
    if (saveProgressStatusEl) saveProgressStatusEl.textContent = status || '';
  }

  function setSaveProgress(value, max, status) {
    if (!saveProgressArea || !saveProgressEl || !saveProgressCountEl) return;
    const m = Math.max(1, Number.isFinite(max) ? max : saveProgressEl.max || 1);
    const v = Math.max(0, Math.min(m, Number.isFinite(value) ? value : saveProgressEl.value || 0));
    saveProgressEl.max = m;
    saveProgressEl.value = v;
    saveProgressCountEl.textContent = `${v}/${m}`;
    if (saveProgressStatusEl && typeof status === 'string') saveProgressStatusEl.textContent = status;
  }

  async function saveAll() {
    if (!items.length && !quantitiesFromJson.size) {
      alert('Nincs menthető hópehely.');
      return;
    }

    const allCodesSet = new Set();
    for (const item of items) {
      allCodesSet.add(item.code);
      quantitiesFromJson.set(item.code,
        Number.isFinite(item.quantity) ? item.quantity : 0);
    }
    for (const [code] of quantitiesFromJson.entries()) {
      allCodesSet.add(code);
    }

    const allCodes = Array.from(allCodesSet);
    const codesWithCounts = [];
    let totalCount = 0;
    for (const code of allCodes) {
      const count = quantitiesFromJson.get(code) ?? 0;
      codesWithCounts.push({ code, count });
      totalCount += Math.max(0, count);
    }

    if (totalCount === 0) {
      if (!confirm('Minden hópehely darabszáma 0. Csak a listát (JSON) szeretnéd menteni?')) {
        return;
      }
    }


    // ====== Mentés folyamatjelző ======
    const nonZeroCodes = codesWithCounts.filter(x => x.count > 0).length;

    const algoSel = (document.getElementById('dxfAlgoSelect')?.value || 'B');
    const algoList = (algoSel === 'all') ? ['A','B'] : [algoSel];

    const progressMax = Math.max(1, totalCount * algoList.length);
    let instanceDone = 0;
    let geomDone = 0;

    showSaveProgress(0, progressMax, (totalCount > 0 ? 'Előkészítés…' : 'JSON mentés…'));
    await saveUiTick();

    const now = new Date();
    const baseName = 'HAVAZO_' + formatTimestampForName(now);

    for (const algo of algoList) {
        const flakeData = [];
        let maxWidth = 0;
        let maxHeight = 0;

        geomDone = 0; // algoritmusonként újraszámoljuk

        for (const { code, count } of codesWithCounts) {
          if (count <= 0) continue;
          const geom = computeContoursForCode(code, algo);
          if (!geom || !geom.contoursWithFlags.length) continue;

          const contours = geom.contoursWithFlags;
          let minX = Infinity, maxX = -Infinity;
          let minY = Infinity, maxY = -Infinity;
          for (const c of contours) {
            const unique = c.points.slice(0, c.points.length - 1);
            for (const [x,y] of unique) {
              if (x < minX) minX = x;
              if (x > maxX) maxX = x;
              if (y < minY) minY = y;
              if (y > maxY) maxY = y;
            }
          }
          const width  = maxX - minX;
          const height = maxY - minY;
          maxWidth  = Math.max(maxWidth, width);
          maxHeight = Math.max(maxHeight, height);

          flakeData.push({ code, count, contours, minX, maxX, minY, maxY, width, height });
          geomDone++;
          setSaveProgress(instanceDone, progressMax, `Geometria számítás… ${geomDone}/${nonZeroCodes}`);
          await saveUiTick();
        }

        let dxfString = '';
        if (totalCount > 0 && flakeData.length > 0) {
          const layoutMode = (document.getElementById('layoutModeSelect')?.value || 'grid');
          let sheetW = parseFloat(document.getElementById('sheetWidthInput')?.value ?? '600');
          let sheetH = parseFloat(document.getElementById('sheetHeightInput')?.value ?? '400');
          let clearance = parseFloat(document.getElementById('shapeGapInput')?.value ?? '2');

          if (!Number.isFinite(sheetW) || sheetW <= 0) sheetW = 600;
          if (!Number.isFinite(sheetH) || sheetH <= 0) sheetH = 400;
          if (!Number.isFinite(clearance) || clearance < 0) clearance = 2;

          // A "Köz" a tényleges biztonsági távolság két alakzat közt.
          // Ehhez oldalanként pad = clearance/2 margót számolunk a pakolásnál.
          const pad = clearance / 2;
          const SHEET_SPACING = 100.0; // mm, két kirakási terület közt

          // Blokk név: a PEHELY-kód DXF-kompatibilis változata (core-ban egységesítve)
          const blockNameForCode = (code) => (algo + '_' + PC.blockNameFromCode(code));

          // BLOCK-ok előkészítése: a core generálja a DXF-ben a kontúrokat + felfüggesztő furatot.
          const blocks = [];
          const blockNames = new Map(); // code -> blockName
          for (const flake of flakeData) {
            const blockName = blockNameForCode(flake.code);
            blockNames.set(flake.code, blockName);

            const cx = (flake.minX + flake.maxX) / 2;
            const cy = (flake.minY + flake.maxY) / 2;
            const pHole = PC.paramsFromCode(flake.code);

            blocks.push({
              blockName,
              contoursWithFlags: flake.contours,
              centerX: cx,
              centerY: cy,
              minRectMm: pHole.minRectMm,
              includeHole: true
            });
          }

          const placements = []; // { blockName, x, y, sheetIndex }
          let maxSheetIndex = 0;

                if (layoutMode === 'circle') {
            // Kör (circle) pakolás: befoglaló körök, hex-szerű elrendezés, átmérő szerint rendezve
            const circleTypes = [...flakeData].map(f => {
              const cx = (f.minX + f.maxX) / 2;
              const cy = (f.minY + f.maxY) / 2;
              let maxR = 0;
              for (const c of f.contours) {
                if (!c.isOuter) continue;
                const pts = c.points.slice(0, c.points.length - 1);
                for (const [x, y] of pts) {
                  const d = Math.hypot(x - cx, y - cy);
                  if (d > maxR) maxR = d;
                }
              }
              // Biztonsági fallback, ha valamiért nincs külső kontúr jelölve
              if (!(maxR > 0)) maxR = 0.5 * Math.max(f.width, f.height);
              const rEff = maxR + pad; // külső sugár + köz/2
              return { code: f.code, count: f.count, r: rEff, d: 2 * rEff };
            }).sort((a, b) => b.d - a.d);

            const SQRT3_OVER_2 = Math.sqrt(3) / 2;

            let tIdx = 0;
            let tRep = 0;
            let _current = null;

            function peekCircle() {
              if (_current) return _current;
              while (tIdx < circleTypes.length) {
                const t = circleTypes[tIdx];
                if (tRep < t.count) {
                  _current = { code: t.code, r: t.r };
                  return _current;
                }
                tIdx++;
                tRep = 0;
              }
              return null;
            }

            function takeCircle() {
              const c = peekCircle();
              if (!c) return null;
              _current = null;
              tRep++;
              return c;
            }

            let sheetIndex = 0;
            let rowIndex = 0;
            let placedCircles = []; // aktuális kirakási területre: { x, y, r }
            let lastRowY = 0;
            let lastRowMaxR = 0;

            function resetForNewSheet() {
              sheetIndex++;
              rowIndex = 0;
              placedCircles = [];
              lastRowY = 0;
              lastRowMaxR = 0;
            }

            while (true) {
              const firstPeek = peekCircle();
              if (!firstPeek) break;

              // Új sor felépítése (balról jobbra), az első (legnagyobb maradék) kör sugara meghatározza a sor eltolását
              const rowMaxR = firstPeek.r;
              const rowOffset = (rowIndex % 2) * rowMaxR; // hex eltolás
              let x = rowMaxR + rowOffset;

              const row = []; // { code, r, x }
              const first = takeCircle();
              row.push({ code: first.code, r: first.r, x });
              let prevR = first.r;

              while (true) {
                const nxt = peekCircle();
                if (!nxt) break;
                const nx = x + prevR + nxt.r;
                if (nx + nxt.r > sheetW) break; // nem fér a sorba
                x = nx;
                const c = takeCircle();
                row.push({ code: c.code, r: c.r, x });
                prevR = c.r;
              }

              // Sor Y pozíció (hex-szerűen): induló tipp + ütközésmentes lejjebb tolás
              let y = rowMaxR;
              if (placedCircles.length > 0) {
                y = lastRowY + SQRT3_OVER_2 * (lastRowMaxR + rowMaxR);

                // Biztosítsuk, hogy egyetlen kör se lógjon rá a már elhelyezettekre (konzervatív, de stabil)
                for (const rc of row) {
                  for (const pc of placedCircles) {
                    const dx = Math.abs(rc.x - pc.x);
                    const rsum = rc.r + pc.r;
                    if (dx < rsum) {
                      const needY = pc.y + Math.sqrt((rsum * rsum) - (dx * dx));
                      if (needY > y) y = needY;
                    }
                  }
                }
              }

              // Ha nem férne bele a kirakási terület magasságába, új területet kezdünk (100mm hézaggal lejjebb)
              if (y + rowMaxR > sheetH && placedCircles.length > 0) {
                resetForNewSheet();

                // Új területen a sor bal-felsőből indul újra (eltolás nélküli első sor)
                rowIndex = 0;
                let rx = rowMaxR;
                row[0].x = rx;
                let pr = row[0].r;
                for (let i = 1; i < row.length; i++) {
                  rx = rx + pr + row[i].r;
                  row[i].x = rx;
                  pr = row[i].r;
                }
                y = rowMaxR;
              }

              const sheetOffset = sheetIndex * (sheetH + SHEET_SPACING);

              for (const rc of row) {
                const blockName = blockNames.get(rc.code);
                const insX = rc.x;
                const insY = -(sheetOffset + y);

                placements.push({ blockName, x: insX, y: insY, sheetIndex });
                placedCircles.push({ x: rc.x, y: y, r: rc.r });

                instanceDone++;
                setSaveProgress(instanceDone, progressMax, 'Elrendezés…');
                await saveUiTick();

                if (sheetIndex > maxSheetIndex) maxSheetIndex = sheetIndex;
              }

              lastRowY = y;
              lastRowMaxR = rowMaxR;
              rowIndex++;
            }

          } else if (layoutMode === 'shelf') {
            // Polc (shelf) pakolás: sorok változó magassággal
            const sortedTypes = [...flakeData].sort((a, b) => {
              const ah = a.height + 2 * pad;
              const bh = b.height + 2 * pad;
              if (bh !== ah) return bh - ah;
              const aw = a.width + 2 * pad;
              const bw = b.width + 2 * pad;
              return bw - aw;
            });

            let sheetIndex = 0;
            let x = 0;
            let y = 0;
            let shelfH = 0;

            for (const flake of sortedTypes) {
              const blockName = blockNames.get(flake.code);
              const bboxW = flake.width + 2 * pad;
              const bboxH = flake.height + 2 * pad;

              if (bboxW > sheetW || bboxH > sheetH) {
                console.warn(`A(z) ${flake.code} hópehely (bbox ${bboxW.toFixed(2)}×${bboxH.toFixed(2)} mm) nagyobb, mint a kirakási terület (${sheetW}×${sheetH} mm). Kilóghat a keretből.`);
              }

              for (let i = 0; i < flake.count; i++) {
                if (x > 0 && (x + bboxW) > sheetW) {
                  y += shelfH;
                  x = 0;
                  shelfH = 0;
                }
                if (y > 0 && (y + bboxH) > sheetH) {
                  sheetIndex++;
                  x = 0;
                  y = 0;
                  shelfH = 0;
                }

                const centerX = x + pad + (flake.width / 2);
                const centerYDown = y + pad + (flake.height / 2);
                const sheetOffset = sheetIndex * (sheetH + SHEET_SPACING);
                const insX = centerX;
                const insY = -(sheetOffset + centerYDown);

                placements.push({ blockName, x: insX, y: insY, sheetIndex });
                instanceDone++;
                setSaveProgress(instanceDone, progressMax, 'Elrendezés…');
                await saveUiTick();
                if (sheetIndex > maxSheetIndex) maxSheetIndex = sheetIndex;

                x += bboxW;
                shelfH = Math.max(shelfH, bboxH);
              }
            }
          } else {
            // Rács (grid): azonos cellák (a legnagyobb pehely alapján)
            const cellSize = Math.max(maxWidth, maxHeight) + 2 * pad; // = maxDim + clearance
            let colsPerSheet = Math.floor(sheetW / cellSize);
            let rowsPerSheet = Math.floor(sheetH / cellSize);
            if (colsPerSheet < 1) colsPerSheet = 1;
            if (rowsPerSheet < 1) rowsPerSheet = 1;
            const capacityPerSheet = colsPerSheet * rowsPerSheet;

            let index = 0;
            for (const flake of flakeData) {
              const blockName = blockNames.get(flake.code);
              for (let i = 0; i < flake.count; i++) {
                const sheetIndex = Math.floor(index / capacityPerSheet);
                const within = index % capacityPerSheet;
                const row = Math.floor(within / colsPerSheet);
                const col = within % colsPerSheet;

                const centerX = (col * cellSize) + (cellSize / 2);
                const centerYDown = (row * cellSize) + (cellSize / 2);
                const sheetOffset = sheetIndex * (sheetH + SHEET_SPACING);
                const insY = -(sheetOffset + centerYDown);

                placements.push({ blockName, x: centerX, y: insY, sheetIndex });
                instanceDone++;
                setSaveProgress(instanceDone, progressMax, 'Elrendezés…');
                await saveUiTick();
                if (sheetIndex > maxSheetIndex) maxSheetIndex = sheetIndex;
                index++;
              }
            }
          }

          const frames = [];
          for (let s = 0; s <= maxSheetIndex; s++) {
            frames.push({
              sheetW,
              sheetH,
              offsetDown: s * (sheetH + SHEET_SPACING),
              layer: 'Keret'
            });
          }

          const inserts = placements.map(p => ({
            blockName: p.blockName,
            x: p.x,
            y: p.y,
            layer: '0',
            scale: 1,
            rotationDeg: 0
          }));

          dxfString = PC.buildCollectionDxf({ blocks, frames, inserts });

          setSaveProgress(instanceDone, progressMax, 'DXF összeállítva.');
          await saveUiTick();
        }

        const algoBaseName = `${algo}_${baseName}`;

        if (dxfString) {
          await saveWithPickerOrDownload(algoBaseName + '.dxf', 'application/dxf', dxfString);
          setSaveProgress(instanceDone, progressMax, 'DXF mentve.');
          await saveUiTick();
        }
    }

const jsonData = {
      version: ('HAVAZO_' + ((PC && PC.VERSION) ? PC.VERSION.toUpperCase() : 'V62')),
      generatedAt: now.toISOString(),
      items: codesWithCounts
    };
    const jsonText = JSON.stringify(jsonData, null, 2);
    await saveWithPickerOrDownload(baseName + '.json', 'application/json', jsonText);
    setSaveProgress(instanceDone, progressMax, 'JSON mentve.');
    await saveUiTick();

    setSaveProgress(progressMax, progressMax, 'Kész.');
    await saveUiTick();
    if (saveProgressArea) saveProgressArea.style.display = 'none';
    alert('Mentés kész: DXF és JSON létrehozva (ahol engedélyezve volt).');
  }

  // ====== TESZT: algoritmusok összehasonlítása és eltérések DXF-be ======
  function _roundSig(v) { return Math.round(v * 1000) / 1000; } // 0.001 mm
  function _minPointIndices(pts) {
    let minX = pts[0][0], minY = pts[0][1];
    for (let i = 1; i < pts.length; i++) {
      const x = pts[i][0], y = pts[i][1];
      if (x < minX || (x === minX && y < minY)) { minX = x; minY = y; }
    }
    const idxs = [];
    for (let i = 0; i < pts.length; i++) {
      if (pts[i][0] === minX && pts[i][1] === minY) idxs.push(i);
    }
    return idxs;
  }
  function _rotateToIndex(pts, idx) {
    if (idx <= 0) return pts;
    return pts.slice(idx).concat(pts.slice(0, idx));
  }
  function _ptsToString(pts) {
    // pts: [[x,y],...], already rounded
    let s = '';
    for (let i = 0; i < pts.length; i++) {
      const p = pts[i];
      s += p[0] + ',' + p[1] + ';';
    }
    return s;
  }
  function _canonicalLoop(pointsUnique) {
    if (!pointsUnique || pointsUnique.length < 3) return '';
    const pts = pointsUnique.map(([x, y]) => [_roundSig(x), _roundSig(y)]);
    const idxsF = _minPointIndices(pts);
    let best = null;

    for (const idx of idxsF) {
      const rot = _rotateToIndex(pts, idx);
      const s = _ptsToString(rot);
      if (best === null || s < best) best = s;
    }
    // reversed orientation
    const rev = pts.slice().reverse();
    const idxsR = _minPointIndices(rev);
    for (const idx of idxsR) {
      const rot = _rotateToIndex(rev, idx);
      const s = _ptsToString(rot);
      if (best === null || s < best) best = s;
    }
    return best || '';
  }
  function _contoursSignature(contours) {
    if (!contours || !contours.length) return 'NULL';
    const parts = [];
    for (const c of contours) {
      if (!c || !c.points || c.points.length < 4) continue;
      const unique = c.points.slice(0, c.points.length - 1);
      const loopSig = _canonicalLoop(unique);
      if (!loopSig) continue;
      parts.push((c.isOuter ? 'O:' : 'I:') + loopSig);
    }
    parts.sort();
    return parts.join('|') || 'NULL';
  }

  async function runTest() {
    if (!items.length && !quantitiesFromJson.size) return;

    // Gyűjtsük össze az összes kódot és darabszámot (saveAll logika szerint)
    const allCodesSet = new Set();
    for (const item of items) {
      allCodesSet.add(item.code);
      quantitiesFromJson.set(item.code, Number.isFinite(item.quantity) ? item.quantity : 0);
    }
    for (const [code] of quantitiesFromJson.entries()) allCodesSet.add(code);

    const codesWithCounts = [];
    for (const code of allCodesSet) {
      const count = Number(quantitiesFromJson.get(code) || 0);
      if (count > 0) codesWithCounts.push({ code, count });
    }
    if (codesWithCounts.length === 0) return;

    // C algoritmus eltávolítva. TESZT: A, B.
    const algos = ['A', 'B'];
    const totalChecks = codesWithCounts.length * algos.length;

    showSaveProgress(0, Math.max(1, totalChecks), 'TESZT: összehasonlítás…');
    await saveUiTick();

    // Csak az egymás utáni algoritmusok eredményeit hasonlítjuk (B vs A)
    const rows = []; // { code, perAlgo: {A:{...},...}, sigs:{...}, firstDiffAlgo }
    let done = 0;
    let diffRows = 0;

    for (const entry of codesWithCounts) {
      const code = entry.code;

      const sigs = {};
      const perAlgo = {};
      let prevSig = null;
      let firstDiffAlgo = null;

      for (const algo of algos) {
        const geom = computeContoursForCode(code, algo);
        const contours = (geom && geom.contoursWithFlags) ? geom.contoursWithFlags : null;
        const sig = _contoursSignature(contours);
        sigs[algo] = sig;

        if (prevSig !== null && firstDiffAlgo === null && sig !== prevSig) firstDiffAlgo = algo;
        prevSig = sig;

        if (contours && contours.length) {
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          for (const c of contours) {
            const unique = c.points.slice(0, c.points.length - 1);
            for (const [x, y] of unique) {
              if (x < minX) minX = x;
              if (x > maxX) maxX = x;
              if (y < minY) minY = y;
              if (y > maxY) maxY = y;
            }
          }
          perAlgo[algo] = { contours, minX, minY, maxX, maxY, width: (maxX - minX), height: (maxY - minY) };
        } else {
          perAlgo[algo] = { contours: null, minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0 };
        }

        done++;
        setSaveProgress(done, totalChecks, `TESZT: ${done}/${totalChecks}`);
        await saveUiTick();
      }

      if (firstDiffAlgo !== null) diffRows++;
      rows.push({ code, perAlgo, sigs, firstDiffAlgo });
    }

    // DXF összeállítás: algoritmusonként oszlopokba rendezve (A | B | D).
    // A oszlop (referencia) mindig szerepel minden kódhoz.
    let clearance = parseFloat(document.getElementById('shapeGapInput')?.value ?? '2');
    if (!Number.isFinite(clearance) || clearance < 0) clearance = 2;

    const blocksByName = new Map();
    const inserts = [];

    // Oszlopszélességek: a sorok között algoritmusonként a max szélesség
    const colW = {};
    for (const algo of algos) colW[algo] = 0;
    for (const row of rows) {
      for (const algo of algos) colW[algo] = Math.max(colW[algo], (row.perAlgo[algo]?.width || 0));
    }

    // Oszlop bal szélek
    const colLeft = {};
    let xAcc = 0;
    for (const algo of algos) {
      colLeft[algo] = xAcc;
      xAcc += colW[algo] + clearance;
    }

    let rowTop = 0;
    for (const row of rows) {
      // sor magasság: max az algoritmusok között
      let rowH = 0;
      for (const algo of algos) rowH = Math.max(rowH, (row.perAlgo[algo]?.height || 0));

      const yCenter = -(rowTop + (rowH / 2));

      for (let ai = 0; ai < algos.length; ai++) {
        const algo = algos[ai];
        const v = row.perAlgo[algo];

        // oszlopon belül középre igazítás
        const xCenter = colLeft[algo] + (colW[algo] / 2);

        // Ha az adott algoritmus eredménye megegyezik az előzőével, hagyjuk üresen az oszlopot (a hely megmarad).
        // (A mindig bekerül, mert referencia.)
        if (ai > 0) {
          const prevAlgo = algos[ai - 1];
          if ((row.sigs?.[algo] ?? null) === (row.sigs?.[prevAlgo] ?? null)) continue;
        }

        // Ha nincs kontúr, hagyjuk üresen az oszlopot (a hely attól még megmarad)
        if (!v || !v.contours || !v.contours.length) continue;

        const blockName = algo + '_' + PC.blockNameFromCode(row.code);
        const cx = (v.minX + v.maxX) / 2;
        const cy = (v.minY + v.maxY) / 2;
        const pHole = PC.paramsFromCode(row.code);

        if (!blocksByName.has(blockName)) {
          blocksByName.set(blockName, {
            blockName,
            contoursWithFlags: v.contours,
            centerX: cx,
            centerY: cy,
            minRectMm: pHole.minRectMm,
            includeHole: true
          });
        }

        inserts.push({ blockName, x: xCenter, y: yCenter, layer: '0', scale: 1, rotationDeg: 0 });
      }

      rowTop += rowH + clearance;
    }

    const dxfString = PC.buildCollectionDxf({
      blocks: Array.from(blocksByName.values()),
      frames: [],
      inserts
    });

    const now = new Date();
    const name = 'TESZT_' + formatTimestampForName(now) + '.dxf';

    setSaveProgress(totalChecks, totalChecks, `TESZT: mentés… (sor: ${rows.length}, eltérés: ${diffRows})`);
    await saveUiTick();

    await saveWithPickerOrDownload(name, 'application/dxf', dxfString);

    if (saveProgressArea) saveProgressArea.style.display = 'none';
  }


  // ====== Init ======
  window.addEventListener('load', () => {
    // Verzió (kívül-belül egységesen)
    const vEl = document.getElementById('appVersion');
    const v = (PC && PC.VERSION) ? PC.VERSION : 'v81.1';
    if (vEl) vEl.textContent = v;
    document.title = 'Rodé Lajos - HAVAZO ' + v;

    // DXF algoritmus választó + leírás
    const dxfAlgoSelect = document.getElementById('dxfAlgoSelect');
    const dxfAlgoDesc = document.getElementById('dxfAlgoDesc');
    const DXF_ALGO_DESCS = {
      all: 'MIND: az összes algoritmussal külön DXF-et készít (A, B).',
      A: 'A: eredeti kontúrképzés (metszéssplit + oldal-mintavétel + gráfbejárás).',
      B: 'B: jelenlegi kontúrképzés: A + adaptív oldal-mintavételi eltolás + finomabb csúcssnap + split-összevonás (robosztusabb).'
    };
    function refreshAlgoDesc() {
      const key = dxfAlgoSelect ? dxfAlgoSelect.value : 'B';
      if (dxfAlgoDesc) dxfAlgoDesc.value = DXF_ALGO_DESCS[key] || '';
    }
    if (dxfAlgoSelect) dxfAlgoSelect.addEventListener('change', refreshAlgoDesc);
    refreshAlgoDesc();


    // GENERÁTOR gomb: host (iframe) módban fülváltás, különben navigáció.
    const gotoLink = document.getElementById('gotoPehelyLink');
    if (gotoLink) {
      gotoLink.addEventListener('click', (ev) => {
        if (window.parent && window.parent !== window) {
          ev.preventDefault();
          window.parent.postMessage({ type: 'switchTab', tab: 'pehely' }, '*');
        }
      });
    }

    document.getElementById('chooseFolderBtn')
      .addEventListener('click', pickFolderAndScan);
    document.getElementById('folderFileInput').addEventListener('change', onFolderFilesSelected);
    document.getElementById('jsonFileInput').addEventListener('change', onJsonFileSelected);
    document.getElementById('loadListBtn')
      .addEventListener('click', loadListFromJson);
    document.getElementById('generateMissingBtn')
      .addEventListener('click', generateMissingImages);
    document.getElementById('bulkApplyBtn')
      .addEventListener('click', applyBulkQuantity);
    document.getElementById('testBtn')
      .addEventListener('click', runTest);
    document.getElementById('saveAllBtn')
      .addEventListener('click', saveAll);

    // induláskor is nullázzuk az összesítőket
    updateSummaryCounts();
  });
</script>
</body>
</html>
