<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rodé Lajos - HAVAZO v53</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont,
                   "Segoe UI", sans-serif;
    }
    body {
      margin: 0;
      padding: 0;
      background: #f2f4f8;
      color: #222;
    }
    h1 {
      font-size: 1.4rem;
      margin: 0 0 0.4rem 0;
    }
    .version {
      font-weight: normal;  /* verziószám ne legyen félkövér */
      margin-left: 0.2rem;
    }
    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem;
    }

    .top-bar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 0.6rem;
      margin-bottom: 0.7rem;
    }
    .folder-info {
      font-size: 0.9rem;
    }
    .folder-info strong {
      font-weight: 600;
    }

    button, .btn-link {
      padding: 0.35rem 0.7rem;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      transition: background 0.15s, box-shadow 0.15s, transform 0.05s;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
      white-space: nowrap;
    }
    button.secondary, .btn-secondary {
      background: #e9ecef;
      color: #222;
    }
    button.primary, .btn-primary {
      background: #0d6efd;
      color: #fff;
    }
    button:hover,
    .btn-link:hover {
      box-shadow: 0 1px 4px rgba(0,0,0,0.18);
    }
    button:active,
    .btn-link:active {
      transform: translateY(1px);
      box-shadow: none;
    }

    .cards-container {
      margin-top: 0.6rem;
      background: #fff;
      border-radius: 8px;
      padding: 0.7rem;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      min-height: 200px;
    }
    .cards-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 0.75rem;
    }

    .snowflake-card {
      background: #ffffff;
      border-radius: 10px;
      padding: 0.4rem 0.4rem 0.35rem;
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
      display: flex;
      flex-direction: column;
      align-items: center;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }
    .snowflake-card:hover {
      transform: translateY(-2px) scale(1.03);
      box-shadow: 0 4px 12px rgba(0,0,0,0.16);
    }

    .thumb-wrapper {
      width: 100%;
      background: #f2f2f2;
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .thumb-wrapper img {
      display: block;
      max-width: 100%;
      max-height: 100%;
      border-radius: 8px;
      background: transparent;
      aspect-ratio: 15 / 16;  /* a 600x640-hez közeli arány */
      object-fit: cover;
    }

    .qty-row {
      margin-top: 0.3rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
      font-size: 0.85rem;
    }
    .qty-row input[type="number"] {
      width: 3.5rem;
      padding: 0.15rem 0.2rem;
      text-align: center;
    }

    .bottom-bar {
      margin-top: 0.8rem;
      display: flex;
      flex-wrap: wrap;
      align-items: flex-end;
      justify-content: space-between;
      gap: 0.6rem;
    }
    .bottom-left {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }
    .bottom-right {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-end;
      gap: 0.4rem;
    }
    .bottom-right input[type="number"] {
      width: 4rem;
      padding: 0.15rem 0.2rem;
      text-align: center;
    }

    .note {
      font-size: 0.75rem;
      margin-top: 0.4rem;
      color: #555;
    }

    /* Előnézet overlay */
    #previewOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    #previewOverlay.active {
      display: flex;
    }
    .preview-content {
      background: #001633;
      color: #ffffff;
      border-radius: 10px;
      padding: 1rem 1.5rem 1.2rem;
      max-width: 90vw;
      max-height: 90vh;
      box-shadow: 0 8px 24px rgba(0,0,0,0.5);
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.6rem;
    }
    .preview-image-wrapper {
      max-width: 80vw;
      max-height: 70vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #previewImage {
      max-width: 100%;
      max-height: 100%;
      border-radius: 8px;
    }
    #previewCode {
      font-size: 0.95rem;
      letter-spacing: 0.04em;
      text-align: center;
      word-break: break-all;
    }
    #previewCloseBtn {
      position: absolute;
      top: 0.25rem;
      right: 0.6rem;
      background: transparent;
      border: none;
      color: #ffffff;
      font-size: 1.3rem;
      cursor: pointer;
    }

    @media (max-width: 700px) {
      .bottom-bar {
        flex-direction: column;
        align-items: stretch;
      }
      .bottom-right {
        justify-content: flex-start;
      }
    }
    /* Kártya státusz: a JPG megléte a bélyegképen látszik (kék vs bordó), a keret semleges. */
</style>
</head>
<body>
<div class="page">
  <h1>Rodé Lajos - HAVAZO <span class="version">v53</span></h1>

  <div class="top-bar">
    <div class="folder-info">
      Aktuális mappa:
      <strong id="currentFolderName">Letöltések (alapértelmezett – válassz mappát)</strong>
    </div>
    <button id="chooseFolderBtn" class="secondary">Mappa kijelölése</button>
      <input id="folderFileInput" type="file" accept="image/jpeg" multiple webkitdirectory directory style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0">
      <input id="jsonFileInput" type="file" accept="application/json,.json" style="display:none">

  </div>

  <div class="cards-container">
    <div id="cardsGrid" class="cards-grid">
      <!-- kártyák ide kerülnek -->
    </div>
    <div id="emptyMessage" class="note">
      Válassz munkamappát a hópelyhek betöltéséhez.
    </div>
  </div>

  <!-- ÚJ összesítő sorok -->
  <div id="summaryInfo" class="note">
    A mappában szereplő összes típus:
    <span id="summaryAllTypes">0</span> db<br>
    Kiválasztott típusok:
    <span id="summarySelectedTypes">0</span> db<br>
    Mentendő összesen:
    <span id="summaryTotalPieces">0</span> db
  </div>

  <div class="bottom-bar">
    <div class="bottom-left">
      <a href="index.html" class="btn-link btn-secondary">GENERÁTOR</a>
    </div>
    <div class="bottom-right">
      <button id="loadListBtn" class="secondary">Lista betöltése</button>
      <button id="generateMissingBtn" class="secondary">Hiányzó képek generálása</button>

      <div style="display:flex;align-items:center;gap:0.25rem;">
        <input id="bulkQtyInput" type="number" min="0" step="1" value="1">
        <span>db</span>
      </div>
      <button id="bulkApplyBtn" class="secondary">mind</button>
      <button id="saveAllBtn" class="primary">MENTÉS</button>
    </div>
  </div>
</div>

<!-- Nagy előnézet overlay -->
<div id="previewOverlay">
  <div class="preview-content" id="previewContent">
    <button id="previewCloseBtn" title="Bezárás">✕</button>
    <div class="preview-image-wrapper">
      <img id="previewImage" src="" alt="Hópelyhes előnézet">
    </div>
    <div id="previewCode"></div>
  </div>
</div>

<script src="./pehely-core_v53.js"></script>

<script>

  // ====== PehelyCore (közös algoritmus modul) ======
  const PC = window.PehelyCore;
  if (!PC) {
    alert('Hiányzik a pehely-core.js (tedd a HTML-ek mellé ugyanabba a mappába).');
    throw new Error('PehelyCore hiányzik');
  }
  const {
    paramsFromCode,
    buildSnowflakeSegments,
    // FONTOS: ne vegyük fel computeContoursForCode néven, mert lent ugyanilyen
    // néven van egy helyi (cache-elő) wrapperünk. Ha mindkettő ugyanaz a név,
    // az szintaktikai hibát okoz, és emiatt SEMMILYEN gomb nem fog működni.
    computeContoursForCode: coreComputeContoursForCode,
    computeContoursForParams,
    computePolysForCode,
    createJpegBlobForCode,
    parseCodeFromJpegArrayBuffer,
    addJpegCommentToArrayBuffer
  } = PC;

  // ====== Általános segédek ======
  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // ====== Save manager: mappa ha lehet, különben Letöltések ======
  const saveManager = (() => {
    // mode: 'unknown' | 'dir' | 'download'
    let mode = 'unknown';
    let outDirHandle = null;

    function canUseDir() {
      return !!window.showDirectoryPicker && !!window.isSecureContext;
    }

    async function ensureOutDir() {
      if (mode === 'download') return null;
      if (outDirHandle) return outDirHandle;

      if (!canUseDir()) {
        mode = 'download';
        return null;
      }

      try {
        outDirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
        if (outDirHandle && outDirHandle.queryPermission) {
          let p = await outDirHandle.queryPermission({ mode: 'readwrite' });
          if (p !== 'granted' && outDirHandle.requestPermission) {
            p = await outDirHandle.requestPermission({ mode: 'readwrite' });
          }
          if (p !== 'granted') {
            outDirHandle = null;
            mode = 'download';
            return null;
          }
        }
        mode = outDirHandle ? 'dir' : 'download';
        return outDirHandle;
      } catch (e) {
        console.warn('Kimeneti mappa kiválasztása megszakítva vagy hiba:', e);
        mode = 'download';
        outDirHandle = null;
        return null;
      }
    }

    async function writeToDir(dirHandle, filename, blob) {
      const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(blob);
      await writable.close();
    }

    async function saveMany(files) {
      const dir = await ensureOutDir();
      if (dir) {
        for (const f of files) {
          try {
            await writeToDir(dir, f.name, f.blob);
          } catch (e) {
            console.warn('Nem sikerült mappába menteni, letöltés lesz:', e);
            downloadBlob(f.blob, f.name);
          }
        }
        return { mode: 'dir' };
      } else {
        for (const f of files) downloadBlob(f.blob, f.name);
        return { mode: 'download' };
      }
    }

    function setOutDirHandle(dirHandleOrNull) {
      outDirHandle = dirHandleOrNull || null;
      mode = outDirHandle ? 'dir' : 'unknown';
    }

    function reset() {
      outDirHandle = null;
      mode = 'unknown';
    }

    return { saveMany, ensureOutDir, setOutDirHandle, reset };
  })();



  async function saveWithPickerOrDownload(suggestedName, mimeType, content) {
    const blob = (content instanceof Blob) ? content : new Blob([content], { type: mimeType });
    await saveManager.saveMany([{ name: suggestedName, blob }]);
  }

  function formatTimestampForName(date) {
    const pad = (n) => String(n).padStart(2, '0');
    const y = date.getFullYear();
    const m = pad(date.getMonth() + 1);
    const d = pad(date.getDate());
    const hh = pad(date.getHours());
    const mm = pad(date.getMinutes());
    const ss = pad(date.getSeconds());
    return `${y}-${m}-${d}_${hh}-${mm}-${ss}`;
  }

  // ====== PEHELY-kód kezelése + geometria (kompatibilis a generátorral) ======

  const DXF_TARGET_SIZE = 100.0; // mm
  const geometryCache = new Map(); // code -> { contoursWithFlags }

  // [KISZERVEZVE pehely-core.js-be] paramsFromCode


  // [KISZERVEZVE pehely-core.js-be] makeRectFromBase


  // [KISZERVEZVE pehely-core.js-be] scalePolygon


  // [KISZERVEZVE pehely-core.js-be] buildSingleTreeSegments


  // [KISZERVEZVE pehely-core.js-be] buildSnowflakeSegments


  // [KISZERVEZVE pehely-core.js-be] buildTentHexFromEdge


  // [KISZERVEZVE pehely-core.js-be] buildRegularHexFromEdge


  // [KISZERVEZVE pehely-core.js-be] buildTrapHexFromEdge


  // [KISZERVEZVE pehely-core.js-be] segmentToPolys


  // [KISZERVEZVE pehely-core.js-be] pointInPolygon


  // [KISZERVEZVE pehely-core.js-be] buildLaserContoursExact


  function computeContoursForCode(codeString, paramsOverride = null) {
    const params = paramsOverride || paramsFromCode(codeString);
    const runoffKey = (params && params.runoff) ? params.runoff : 'Oo.';
    const cacheKey = `${codeString}|RUNOFF:${runoffKey}`;
    if (geometryCache.has(cacheKey)) return geometryCache.get(cacheKey);

    const result = computeContoursForParams(params);
    geometryCache.set(cacheKey, result);
    return result;
  }

  // [KISZERVEZVE pehely-core.js-be] computePolysForCode


  // [KISZERVEZVE pehely-core.js-be] addJpegCommentToArrayBuffer


  // [KISZERVEZVE pehely-core.js-be] createJpegBlobForCode


  // [KISZERVEZVE pehely-core.js-be] parseCodeFromJpegArrayBuffer


  async function readCodeFromJpegFileHandle(fileHandle) {
    const file = await fileHandle.getFile();
    const arrayBuffer = await file.arrayBuffer();
    return parseCodeFromJpegArrayBuffer(arrayBuffer);
  }
  async function readCodeFromJpegFile(file) {
    try {
      const arrayBuffer = await file.arrayBuffer();
      return parseCodeFromJpegArrayBuffer(arrayBuffer);
    } catch (e) {
      console.warn('Nem sikerült a JPG beolvasása:', e);
      return null;
    }
  }


  // ====== HAVAZO adatszerkezetek ======

  let currentDirectoryHandle = null;
  let currentSelectedFiles = null; // File[] fallback (ha nincs / nem működik showDirectoryPicker)

  const cardsGrid = document.getElementById('cardsGrid');
  const emptyMessage = document.getElementById('emptyMessage');
  const currentFolderNameEl = document.getElementById('currentFolderName');

  let items = [];                // { code, fileHandle|null, imgURL, quantity, isVirtual, cardElem, qtyInput }
  const itemsByCode = new Map(); // code -> item
  const quantitiesFromJson = new Map(); // code -> count (0 is megőrződik)

  // Summary elemek
  const summaryAllTypesEl      = document.getElementById('summaryAllTypes');
  const summarySelectedTypesEl = document.getElementById('summarySelectedTypes');
  const summaryTotalPiecesEl   = document.getElementById('summaryTotalPieces');

  function updateSummaryCounts() {
    // összes típus a mappában: olyan itemek, amelyeknek van valódi fileHandle-je
    const totalFolderTypes = items.filter(it => !!it.fileHandle).length;

    // kiválasztott típusok: item.quantity > 0
    let selectedTypes = 0;
    let totalPieces = 0;
    for (const it of items) {
      const q = Number.isFinite(it.quantity) ? it.quantity : 0;
      if (q > 0) selectedTypes++;
      totalPieces += Math.max(0, q);
    }

    summaryAllTypesEl.textContent      = totalFolderTypes.toString();
    summarySelectedTypesEl.textContent = selectedTypes.toString();
    summaryTotalPiecesEl.textContent   = totalPieces.toString();
  }

  // ====== Kártyák + overlay ======

  const previewOverlay = document.getElementById('previewOverlay');
  const previewImage   = document.getElementById('previewImage');
  const previewCodeEl  = document.getElementById('previewCode');
  const previewCloseBtn= document.getElementById('previewCloseBtn');
  const previewContent = document.getElementById('previewContent');

  function openPreviewForItem(item) {
    if (!item || !item.imgURL) return;
    previewImage.src = item.imgURL;
    previewCodeEl.textContent = 'PEHELY-' + item.code;
    previewOverlay.classList.add('active');
  }

  function closePreview() {
    previewOverlay.classList.remove('active');
  }

  previewCloseBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    closePreview();
  });
  previewOverlay.addEventListener('click', () => {
    closePreview();
  });
  previewContent.addEventListener('click', (e) => {
    e.stopPropagation();
  });
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') closePreview();
  });

  function createCardForItem(item) {
    const card = document.createElement('div');
    card.className = 'snowflake-card ' + (item.isVirtual ? 'virtual' : 'has-jpg');

    const thumbWrap = document.createElement('div');
    thumbWrap.className = 'thumb-wrapper';

    const img = document.createElement('img');
    img.src = item.imgURL;
    img.alt = 'Hópehely';

    thumbWrap.appendChild(img);
    card.appendChild(thumbWrap);

    const qtyRow = document.createElement('div');
    qtyRow.className = 'qty-row';

    const qtyInput = document.createElement('input');
    qtyInput.type = 'number';
    qtyInput.min = '0';
    qtyInput.step = '1';
    qtyInput.value = item.quantity.toString();

    const dbSpan = document.createElement('span');
    dbSpan.textContent = 'db';

    qtyRow.appendChild(qtyInput);
    qtyRow.appendChild(dbSpan);
    card.appendChild(qtyRow);

    qtyInput.addEventListener('click', (e) => {
      e.stopPropagation();
    });
    qtyInput.addEventListener('change', () => {
      let v = parseInt(qtyInput.value, 10);
      if (!Number.isFinite(v) || v < 0) v = 0;
      qtyInput.value = v.toString();
      item.quantity = v;
      quantitiesFromJson.set(item.code, v);
      updateSummaryCounts();
    });

    card.addEventListener('click', () => {
      openPreviewForItem(item);
    });

    item.cardElem = card;
    item.qtyInput = qtyInput;
    updateCardClasses(item);
    return card;
  }

  
  function updateCardClasses(item) {
    if (!item || !item.cardElem) return;
    item.cardElem.classList.toggle('virtual', !!item.isVirtual);
    item.cardElem.classList.toggle('has-jpg', !item.isVirtual);
  }

function refreshCardsGrid() {
    cardsGrid.innerHTML = '';
    if (!items.length) {
      emptyMessage.style.display = 'block';
      updateSummaryCounts();
      return;
    }
    emptyMessage.style.display = 'none';
    for (const item of items) {
      const card = createCardForItem(item);
      cardsGrid.appendChild(card);
    }
    updateSummaryCounts();
  }

  // ====== Mappa beolvasása ======

  async function pickFolderAndScan() {
    const folderInput = document.getElementById('folderFileInput');

    if (window.showDirectoryPicker) {
      try {
        const handle = await window.showDirectoryPicker();
        currentDirectoryHandle = handle;
        saveManager.setOutDirHandle(handle);
        currentSelectedFiles = null;
        currentFolderNameEl.textContent = handle.name;
        await scanSources();
        return;
      } catch (e) {
        console.warn('Mappa kijelölése sikertelen (fallback következik):', e);
      }
    }

    if (folderInput) {
      folderInput.value = '';
      folderInput.click();
      return;
    }

    alert('A böngésződben nem érhető el a mappa kiválasztása.');
  }

  
  function cleanupObjectUrls() {
    try {
      for (const it of items) {
        if (it && typeof it.imgURL === 'string' && it.imgURL.startsWith('blob:')) {
          URL.revokeObjectURL(it.imgURL);
        }
      }
    } catch (e) {
      // no-op
    }
  }

  async function scanSelectedFiles() {
    items = [];
    itemsByCode.clear();
    cardsGrid.innerHTML = '';
    emptyMessage.style.display = 'block';

    if (!currentSelectedFiles || !currentSelectedFiles.length) {
      // Nincs kijelölt JPG; ha van JSON-lista, attól még készítünk virtuális kártyákat.
    }

    try {
      for (const file of (currentSelectedFiles || [])) {
        if (!file || !(file.name || '').toLowerCase().endsWith('.jpg')) continue;

        const code = await readCodeFromJpegFile(file);
        if (!code) continue;

        if (itemsByCode.has(code)) continue;

        const url = URL.createObjectURL(file);
        const qty = quantitiesFromJson.has(code) ? quantitiesFromJson.get(code) : 0;

        const item = {
          code,
          fileHandle: null,
          fileName: file.name,
          imgURL: url,
          quantity: qty,
          isVirtual: false,
          cardElem: null,
          qtyInput: null
        };
        items.push(item);
        itemsByCode.set(code, item);
      }
    } catch (e) {
      console.error('Hiba a fájlok beolvasása közben:', e);
    }

    // Régi lista alapján hiányzók virtuális generálása (ugyanúgy, mint mappánál)
    const codesInJson = Array.from(quantitiesFromJson.keys());
    for (const code of codesInJson) {
      if (!itemsByCode.has(code)) {
        try {
          const blob = await createJpegBlobForCode(code, 'bordo');
          if (!blob) continue;
          const url = URL.createObjectURL(blob);
          const qty = quantitiesFromJson.get(code) || 0;
          const item = {
            code,
            fileHandle: null,
            fileName: null,
            imgURL: url,
            quantity: qty,
            isVirtual: true,
            cardElem: null,
            qtyInput: null
          };
          items.push(item);
          itemsByCode.set(code, item);
        } catch (e) {
          console.error('Virtuális kép generálási hiba:', e);
        }
      }
    }

    refreshCardsGrid();
  }

  
  async function suggestWorkFolderIfMissing() {
    // Weben nem tudjuk automatikusan kinyerni a JSON szülőmappáját.
    // Ha nincs munkamappa, felajánljuk, hogy a felhasználó válassza ki (célszerűen ugyanazt a mappát, ahol a JSON van).
    if (currentDirectoryHandle) return;
    if (!window.showDirectoryPicker || !window.isSecureContext) return;

    const ok = confirm('Nincs munkamappa kijelölve. Szeretnéd most kiválasztani a mappát (célszerűen azt, ahol a JSON is van), hogy a JPG-ket oda tudjuk menteni?');
    if (!ok) return;

    try {
      const handle = await window.showDirectoryPicker({ mode: 'readwrite' });
      currentDirectoryHandle = handle;
      currentSelectedFiles = null;
      currentFolderNameEl.textContent = handle.name;
      saveManager.setOutDirHandle(handle);
      await scanSources();
    } catch (e) {
      console.warn('Mappa kijelölése megszakítva vagy hiba:', e);
    }
  }

async function scanSources() {
    cleanupObjectUrls();
    if (currentDirectoryHandle) return scanCurrentFolder();
    return scanSelectedFiles();
  }

  function applyQuantitiesFromJsonData(data) {
    quantitiesFromJson.clear();
    if (data && Array.isArray(data.items)) {
      for (const it of data.items) {
        if (!it || typeof it.code !== 'string') continue;
        const count = Number.isFinite(it.count) ? it.count : 0;
        quantitiesFromJson.set(it.code, count);
      }
    }
  }

  function onFolderFilesSelected(evt) {
    const files = Array.from(evt.target.files || []).filter(f => (f.name || '').toLowerCase().endsWith('.jpg'));
    currentSelectedFiles = files;
    currentDirectoryHandle = null;
    saveManager.setOutDirHandle(null);
    currentFolderNameEl.textContent = files.length ? `Kijelölt fájlok (${files.length})` : '—';
    scanSources();
  }

  function onJsonFileSelected(evt) {
    const file = (evt.target.files && evt.target.files[0]) ? evt.target.files[0] : null;
    if (!file) return;
    file.text().then(text => {
      const data = JSON.parse(text);
      applyQuantitiesFromJsonData(data);
      scanSources().then(() => suggestWorkFolderIfMissing());
    }).catch(e => {
      console.error('JSON beolvasási hiba:', e);
      alert('Nem sikerült beolvasni a JSON-t.');
    });
  }
async function scanCurrentFolder() {
    cleanupObjectUrls();
    items = [];
    itemsByCode.clear();
    cardsGrid.innerHTML = '';
    emptyMessage.style.display = 'block';

    if (!currentDirectoryHandle) {
      updateSummaryCounts();
      return;
    }

    try {
      for await (const entry of currentDirectoryHandle.values()) {
        if (entry.kind === 'file' &&
            entry.name.toLowerCase().endsWith('.jpg')) {

          const code = await readCodeFromJpegFileHandle(entry);
          if (!code) continue;

          if (itemsByCode.has(code)) continue;

          const file = await entry.getFile();
          const url = URL.createObjectURL(file);
          const qty = quantitiesFromJson.has(code) ? quantitiesFromJson.get(code) : 1;

          const item = {
            code,
            fileHandle: entry,
            imgURL: url,
            quantity: qty,
            isVirtual: false,
            cardElem: null,
            qtyInput: null
          };
          items.push(item);
          itemsByCode.set(code, item);
        }
      }
    } catch (e) {
      console.error('Hiba a mappa olvasása közben:', e);
    }

    for (const [code, qty] of quantitiesFromJson.entries()) {
      if (!itemsByCode.has(code)) {
        try {
          const blob = await createJpegBlobForCode(code, 'bordo');
          if (!blob) continue;
          const url = URL.createObjectURL(blob);
          const item = {
            code,
            fileHandle: null,
            imgURL: url,
            quantity: qty,
            isVirtual: true,
            cardElem: null,
            qtyInput: null
          };
          items.push(item);
          itemsByCode.set(code, item);
        } catch (e) {
          console.error('Virtuális kép generálási hiba:', e);
        }
      }
    }

    refreshCardsGrid();
  }

  // ====== Lista betöltése (JSON) ======

  async function loadListFromJson() {
    const jsonInput = document.getElementById('jsonFileInput');

    if (window.showOpenFilePicker) {
      try {
        const [handle] = await window.showOpenFilePicker({
          types: [{
            description: 'HAVAZO lista (JSON)',
            accept: { 'application/json': ['.json'] }
          }]
        });
        const file = await handle.getFile();
        const text = await file.text();
        const data = JSON.parse(text);

        applyQuantitiesFromJsonData(data);
        await scanSources();
      } catch (e) {
        console.warn('Lista betöltése megszakítva vagy hiba:', e);
      }
      return;
    }

    // Fallback: sima file input
    if (jsonInput) {
      jsonInput.value = '';
      jsonInput.click();
      return;
    }

    alert('A böngésződben nem érhető el a JSON betöltése.');
  }

  // ====== Hiányzó képek generálása ======

  async function generateMissingImages() {
    const codesSet = new Set();
    for (const [code] of quantitiesFromJson.entries()) codesSet.add(code);
    for (const item of items) codesSet.add(item.code);

    if (!codesSet.size) {
      alert('Nincs ismert hópehely-kód, amit generálni lehetne.');
      return;
    }

    const missingCodes = [];
    for (const code of codesSet) {
      const item = itemsByCode.get(code);
      if (!item || item.isVirtual) missingCodes.push(code);
    }

    if (!missingCodes.length) {
      alert('Nincs hiányzó kép: minden kódhoz van már betöltött kép.');
      return;
    }

    const files = [];
    const blobsByCode = new Map();

    for (const code of missingCodes) {
      try {
        const blob = await createJpegBlobForCode(code);
        if (!blob) continue;
        blobsByCode.set(code, blob);
        files.push({ name: `PEHELY-${code}.jpg`, blob });
      } catch (e) {
        console.error('Hiba a kép generálásakor:', e);
      }
    }

    if (!files.length) {
      alert('Nem sikerült képet generálni a hiányzókhoz.');
      return;
    }

    await saveManager.saveMany(files);

    for (const [code, blob] of blobsByCode.entries()) {
      const item = itemsByCode.get(code);
      if (!item) continue;

      try { if (item.imgURL) URL.revokeObjectURL(item.imgURL); } catch (_) {}
      item.imgURL = URL.createObjectURL(blob);
      item.isVirtual = false;

      if (item.cardElem) {
        const img = item.cardElem.querySelector('img');
        if (img) img.src = item.imgURL;
        updateCardClasses(item);
      }
    }

    alert('A hiányzó képek elkészültek. (Ha Letöltésekbe mentődtek, másold át őket a munkamappába, majd olvasd be újra a mappát.)');
  }

  // ====== Minden mennyiséget azonosra állító gomb ======

  function applyBulkQuantity() {
    let v = parseInt(document.getElementById('bulkQtyInput').value, 10);
    if (!Number.isFinite(v) || v < 0) v = 0;
    document.getElementById('bulkQtyInput').value = v.toString();

    for (const item of items) {
      item.quantity = v;
      if (item.qtyInput) item.qtyInput.value = v.toString();
      quantitiesFromJson.set(item.code, v);
    }
    updateSummaryCounts();
  }

  // ====== DXF + JSON mentés (MENTÉS gomb) ======

  function translateContour(contour, dx, dy) {
    const unique = contour.slice(0, contour.length - 1);
    const translated = unique.map(([x,y]) => [x + dx, y + dy]);
    translated.push(translated[0].slice());
    return translated;
  }

  async function saveAll() {
    if (!items.length && !quantitiesFromJson.size) {
      alert('Nincs menthető hópehely.');
      return;
    }

    const allCodesSet = new Set();
    for (const item of items) {
      allCodesSet.add(item.code);
      quantitiesFromJson.set(item.code,
        Number.isFinite(item.quantity) ? item.quantity : 0);
    }
    for (const [code] of quantitiesFromJson.entries()) {
      allCodesSet.add(code);
    }

    const allCodes = Array.from(allCodesSet);
    const codesWithCounts = [];
    let totalCount = 0;
    for (const code of allCodes) {
      const count = quantitiesFromJson.get(code) ?? 0;
      codesWithCounts.push({ code, count });
      totalCount += Math.max(0, count);
    }

    if (totalCount === 0) {
      if (!confirm('Minden hópehely darabszáma 0. Csak a listát (JSON) szeretnéd menteni?')) {
        return;
      }
    }

    const flakeData = [];
    let maxWidth = 0;
    let maxHeight = 0;

    for (const { code, count } of codesWithCounts) {
      if (count <= 0) continue;
      const geom = computeContoursForCode(code);
      if (!geom || !geom.contoursWithFlags.length) continue;

      const contours = geom.contoursWithFlags;
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;
      for (const c of contours) {
        const unique = c.points.slice(0, c.points.length - 1);
        for (const [x,y] of unique) {
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
          if (y < minY) minY = y;
          if (y > maxY) maxY = y;
        }
      }
      const width  = maxX - minX;
      const height = maxY - minY;
      maxWidth  = Math.max(maxWidth, width);
      maxHeight = Math.max(maxHeight, height);

      flakeData.push({ code, count, contours, minX, maxX, minY, maxY, width, height });
    }

        let dxfString = '';
    if (totalCount > 0 && flakeData.length > 0) {
      const gap = 2.0; // mm
      const cellSize = Math.max(maxWidth, maxHeight) + 2 * gap;
      const cols = Math.ceil(Math.sqrt(totalCount));

      const NL = '\r\n';
      function add(code, value) {
        dxfString += code + NL + value + NL;
      }
      // Blokk név: a PEHELY-kód DXF-kompatibilis változata (core-ban egységesítve)
      const blockNameForCode = (code) => PehelyCore.blockNameFromCode(code);

add(0, 'SECTION');
      add(2, 'HEADER');
      add(0, 'ENDSEC');

      // ===== BLOCKS: minden hópehely külön BLOCK, (0,0)-ba központosítva =====
      add(0, 'SECTION');
      add(2, 'BLOCKS');

      const blockNames = new Map(); // code -> blockName
      for (const flake of flakeData) {
        const blockName = blockNameForCode(flake.code);
        blockNames.set(flake.code, blockName);

        const cx = (flake.minX + flake.maxX) / 2;
        const cy = (flake.minY + flake.maxY) / 2;

        add(0, 'BLOCK');
        add(8, '0');
        add(2, blockName);
        add(70, 0);
        add(10, 0); add(20, 0); add(30, 0);
        add(3, blockName);
        add(1, '');

        for (const c of flake.contours) {
          const unique = c.points.slice(0, c.points.length - 1);
          if (unique.length < 3) continue;

          add(0, 'LWPOLYLINE');
          add(8, '0');
          add(62, c.isOuter ? 7 : 5);
          add(90, unique.length);
          add(70, 1); // zárt

          for (const [x, y] of unique) {
            add(10, (x - cx).toFixed(4));
            add(20, (y - cy).toFixed(4));
          }
        }

        add(0, 'ENDBLK');
      }

      add(0, 'ENDSEC');

      // ===== ENTITIES: INSERT-ek rácsban, a beszúrási pont a cella közepe =====
      add(0, 'SECTION');
      add(2, 'ENTITIES');

      let index = 0;
      for (const flake of flakeData) {
        const blockName = blockNames.get(flake.code);
        for (let i = 0; i < flake.count; i++) {
          const row = Math.floor(index / cols);
          const col = index % cols;

          const baseX = col * cellSize;
          const baseY = -row * cellSize;

          const cxCell = baseX + cellSize / 2;
          const cyCell = baseY + cellSize / 2;

          add(0, 'INSERT');
          add(8, '0');
          add(2, blockName);
          add(10, cxCell.toFixed(4));
          add(20, cyCell.toFixed(4));
          add(30, 0);
          add(41, 1); add(42, 1); add(43, 1);
          add(50, 0);

          index++;
        }
      }

      add(0, 'ENDSEC');
      add(0, 'EOF');
    }

const now = new Date();
    const baseName = 'HAVAZO_' + formatTimestampForName(now);

    if (dxfString) {
      await saveWithPickerOrDownload(baseName + '.dxf', 'application/dxf', dxfString);
    }

    const jsonData = {
      version: 'HAVAZO_V53',
      generatedAt: now.toISOString(),
      items: codesWithCounts
    };
    const jsonText = JSON.stringify(jsonData, null, 2);
    await saveWithPickerOrDownload(baseName + '.json', 'application/json', jsonText);

    alert('Mentés kész: DXF és JSON létrehozva (ahol engedélyezve volt).');
  }

  // ====== Init ======
  window.addEventListener('load', () => {
    document.getElementById('chooseFolderBtn')
      .addEventListener('click', pickFolderAndScan);
    document.getElementById('folderFileInput').addEventListener('change', onFolderFilesSelected);
    document.getElementById('jsonFileInput').addEventListener('change', onJsonFileSelected);
    document.getElementById('loadListBtn')
      .addEventListener('click', loadListFromJson);
    document.getElementById('generateMissingBtn')
      .addEventListener('click', generateMissingImages);
    document.getElementById('bulkApplyBtn')
      .addEventListener('click', applyBulkQuantity);
    document.getElementById('saveAllBtn')
      .addEventListener('click', saveAll);

    // induláskor is nullázzuk az összesítőket
    updateSummaryCounts();
  });
</script>
</body>
</html>
