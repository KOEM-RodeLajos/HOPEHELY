<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rodé Lajos - HAVAZO v11</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont,
                   "Segoe UI", sans-serif;
    }
    body {
      margin: 0;
      padding: 0;
      background: #f2f4f8;
      color: #222;
    }
    h1 {
      font-size: 1.4rem;
      margin: 0 0 0.4rem 0;
    }
    .version {
      font-weight: normal;  /* verziószám ne legyen félkövér */
      margin-left: 0.2rem;
    }
    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem;
    }

    .top-bar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 0.6rem;
      margin-bottom: 0.7rem;
    }
    .folder-info {
      font-size: 0.9rem;
    }
    .folder-info strong {
      font-weight: 600;
    }

    button, .btn-link {
      padding: 0.35rem 0.7rem;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      transition: background 0.15s, box-shadow 0.15s, transform 0.05s;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
      white-space: nowrap;
    }
    button.secondary, .btn-secondary {
      background: #e9ecef;
      color: #222;
    }
    button.primary, .btn-primary {
      background: #0d6efd;
      color: #fff;
    }
    button:hover,
    .btn-link:hover {
      box-shadow: 0 1px 4px rgba(0,0,0,0.18);
    }
    button:active,
    .btn-link:active {
      transform: translateY(1px);
      box-shadow: none;
    }

    .cards-container {
      margin-top: 0.6rem;
      background: #fff;
      border-radius: 8px;
      padding: 0.7rem;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      min-height: 200px;
    }
    .cards-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 0.75rem;
    }

    .snowflake-card {
      background: #ffffff;
      border-radius: 10px;
      padding: 0.4rem 0.4rem 0.35rem;
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
      display: flex;
      flex-direction: column;
      align-items: center;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }
    .snowflake-card:hover {
      transform: translateY(-2px) scale(1.03);
      box-shadow: 0 4px 12px rgba(0,0,0,0.16);
    }

    .thumb-wrapper {
      width: 100%;
      background: #ffffff;
      border-radius: 10px;
      padding: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .thumb-wrapper img {
      display: block;
      max-width: 100%;
      max-height: 100%;
      border-radius: 8px;
      background: #001633;
      aspect-ratio: 15 / 16;  /* a 600x640-hez közeli arány */
      object-fit: cover;
    }

    .qty-row {
      margin-top: 0.3rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
      font-size: 0.85rem;
    }
    .qty-row input[type="number"] {
      width: 3.5rem;
      padding: 0.15rem 0.2rem;
      text-align: center;
    }

    .bottom-bar {
      margin-top: 0.8rem;
      display: flex;
      flex-wrap: wrap;
      align-items: flex-end;
      justify-content: space-between;
      gap: 0.6rem;
    }
    .bottom-left {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }
    .bottom-right {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-end;
      gap: 0.4rem;
    }
    .bottom-right input[type="number"] {
      width: 4rem;
      padding: 0.15rem 0.2rem;
      text-align: center;
    }

    .note {
      font-size: 0.75rem;
      margin-top: 0.4rem;
      color: #555;
    }

    /* Előnézet overlay */
    #previewOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    #previewOverlay.active {
      display: flex;
    }
    .preview-content {
      background: #001633;
      color: #ffffff;
      border-radius: 10px;
      padding: 1rem 1.5rem 1.2rem;
      max-width: 90vw;
      max-height: 90vh;
      box-shadow: 0 8px 24px rgba(0,0,0,0.5);
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.6rem;
    }
    .preview-image-wrapper {
      max-width: 80vw;
      max-height: 70vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #previewImage {
      max-width: 100%;
      max-height: 100%;
      border-radius: 8px;
    }
    #previewCode {
      font-size: 0.95rem;
      letter-spacing: 0.04em;
      text-align: center;
      word-break: break-all;
    }
    #previewCloseBtn {
      position: absolute;
      top: 0.25rem;
      right: 0.6rem;
      background: transparent;
      border: none;
      color: #ffffff;
      font-size: 1.3rem;
      cursor: pointer;
    }

    @media (max-width: 700px) {
      .bottom-bar {
        flex-direction: column;
        align-items: stretch;
      }
      .bottom-right {
        justify-content: flex-start;
      }
    }
  </style>
</head>
<body>
<div class="page">
  <h1>Rodé Lajos - HAVAZO <span class="version">v11</span></h1>

  <div class="top-bar">
    <div class="folder-info">
      Aktuális mappa:
      <strong id="currentFolderName">Letöltések (alapértelmezett – válassz mappát)</strong>
    </div>
    <button id="chooseFolderBtn" class="secondary">Mappa kijelölése</button>
  </div>

  <div class="cards-container">
    <div id="cardsGrid" class="cards-grid">
      <!-- kártyák ide kerülnek -->
    </div>
    <div id="emptyMessage" class="note">
      Válassz munkamappát a hópelyhek betöltéséhez.
    </div>
  </div>

  <!-- ÚJ összesítő sorok -->
  <div id="summaryInfo" class="note">
    A mappában szereplő összes típus:
    <span id="summaryAllTypes">0</span> db<br>
    Kiválasztott típusok:
    <span id="summarySelectedTypes">0</span> db<br>
    Mentendő összesen:
    <span id="summaryTotalPieces">0</span> db
  </div>

  <div class="bottom-bar">
    <div class="bottom-left">
      <a href="index.html" class="btn-link btn-secondary">GENERÁTOR</a>
    </div>
    <div class="bottom-right">
      <button id="loadListBtn" class="secondary">Lista betöltése</button>
      <button id="generateMissingBtn" class="secondary">Hiányzó képek generálása</button>

      <div style="display:flex;align-items:center;gap:0.25rem;">
        <input id="bulkQtyInput" type="number" min="0" step="1" value="1">
        <span>db</span>
      </div>
      <button id="bulkApplyBtn" class="secondary">mind</button>
      <button id="saveAllBtn" class="primary">MENTÉS</button>
    </div>
  </div>
</div>

<!-- Nagy előnézet overlay -->
<div id="previewOverlay">
  <div class="preview-content" id="previewContent">
    <button id="previewCloseBtn" title="Bezárás">✕</button>
    <div class="preview-image-wrapper">
      <img id="previewImage" src="" alt="Hópelyhes előnézet">
    </div>
    <div id="previewCode"></div>
  </div>
</div>

<script>
  // ====== Általános segédek ======
  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  async function saveWithPickerOrDownload(suggestedName, mimeType, content) {
    const blob = new Blob([content], { type: mimeType });
    if (window.showSaveFilePicker) {
      try {
        const handle = await window.showSaveFilePicker({
          suggestedName,
          types: [{ description: mimeType, accept: { [mimeType]: [ '.' + suggestedName.split('.').pop() ] } }]
        });
        const writable = await handle.createWritable();
        await writable.write(blob);
        await writable.close();
        return;
      } catch (e) {
        console.warn('Mentés megszakítva vagy hiba:', e);
      }
    }
    downloadBlob(blob, suggestedName);
  }

  function formatTimestampForName(date) {
    const pad = (n) => String(n).padStart(2, '0');
    const y = date.getFullYear();
    const m = pad(date.getMonth() + 1);
    const d = pad(date.getDate());
    const hh = pad(date.getHours());
    const mm = pad(date.getMinutes());
    const ss = pad(date.getSeconds());
    return `${y}-${m}-${d}_${hh}-${mm}-${ss}`;
  }

  // ====== PEHELY-kód kezelése + geometria (kompatibilis a generátorral) ======

  const DXF_TARGET_SIZE = 100.0; // mm
  const geometryCache = new Map(); // code -> { contoursWithFlags }

  function paramsFromCode(codeString) {
    const parts = codeString.split('-');
    if (parts.length < 12) {
      throw new Error('Érvénytelen PEHELY kód: ' + codeString);
    }
    const [
      angleStr, ratioStr, spaceStr, redStr,
      tipCode, tipScaleStr, tipOnlyFlag, tipCenterFlag, trunkFlag,
      armsStr, minRectStr, growFlag
    ] = parts;

    const angle   = parseFloat(angleStr) || 0;
    const ratio   = parseFloat(ratioStr) || 0;
    const spacing = parseFloat(spaceStr) || 0;
    const red     = parseFloat(redStr)   || 0;

    let tipMode = 0;
    if      (tipCode === '3S') tipMode = 1;
    else if (tipCode === 'YY') tipMode = 2;
    else if (tipCode === '6S') tipMode = 3;
    else if (tipCode === '4S') tipMode = 4;

    const tipScale   = parseFloat(tipScaleStr);
    const arms       = parseInt(armsStr, 10);
    const minRectMm  = parseFloat(minRectStr);

    return {
      branchAngleDeg:    angle,
      rectAspectPercent: ratio,
      spacingPercent:    spacing,
      reductionPercent:  red,
      tipMode,
      tipScale:          Number.isFinite(tipScale) ? tipScale : 1,
      tipOnly:           (tipOnlyFlag   === 'Y'),
      tipAtCenter:       (tipCenterFlag === 'Y'),
      showTrunk:         (trunkFlag     === 'Y'),
      armCount:          Number.isFinite(arms) ? arms : 6,
      minRectMm:         Number.isFinite(minRectMm) ? minRectMm : 0,
      growSmallRects:    (growFlag === 'Y')
    };
  }

  function makeRectFromBase(bx, by, length, width, angleRad) {
    const d = { x: Math.cos(angleRad), y: Math.sin(angleRad) };
    const n = { x: -Math.sin(angleRad), y: Math.cos(angleRad) };

    const halfL = length / 2;
    const halfW = width / 2;

    const cx = bx + d.x * halfL;
    const cy = by + d.y * halfL;

    const p1 = [ cx + n.x * halfW + d.x * halfL, cy + n.y * halfW + d.y * halfL ];
    const p2 = [ cx - n.x * halfW + d.x * halfL, cy - n.y * halfW + d.y * halfL ];
    const p3 = [ cx - n.x * halfW - d.x * halfL, cy - n.y * halfW - d.y * halfL ];
    const p4 = [ cx + n.x * halfW - d.x * halfL, cy + n.y * halfW - d.y * halfL ];

    return [p1, p2, p3, p4, p1.slice()];
  }

  function scalePolygon(poly, scale) {
    if (!poly || poly.length < 2 || scale === 1) return poly;
    const unique = poly.slice(0, poly.length - 1);
    if (!unique.length) return poly;

    let cx = 0, cy = 0;
    for (const [x, y] of unique) {
      cx += x; cy += y;
    }
    cx /= unique.length;
    cy /= unique.length;

    const scaled = unique.map(([x, y]) => [
      cx + (x - cx) * scale,
      cy + (y - cy) * scale
    ]);
    scaled.push(scaled[0].slice());
    return scaled;
  }

  function buildSingleTreeSegments(params) {
    const segments = [];

    const trunkLength = 50;
    const aspect = Math.max(0.02, params.rectAspectPercent / 100.0);
    const trunkWidth = trunkLength * aspect;

    const trunkAngle = Math.PI / 2;
    const spacing = params.spacingPercent;
    const angleOffset = params.branchAngleDeg * Math.PI / 180.0;
    const reduction = Math.max(0, Math.min(0.95, params.reductionPercent / 100.0));
    const tipMode = params.tipMode;
    const tipScale = Number.isFinite(params.tipScale) ? params.tipScale : 1;

    segments.push({
      bx: 0, by: 0,
      length: trunkLength,
      width: trunkWidth,
      angle: trunkAngle,
      tipMode,
      tipScale,
      isTrunk: true
    });

    const count = Math.floor(100 / spacing);
    if (count <= 0) return segments;

    const dTrunk = { x: Math.cos(trunkAngle), y: Math.sin(trunkAngle) };
    const signs = [+1, -1];

    for (let i = 1; i <= count; i++) {
      const t = i * spacing / 100.0;
      const posOnTrunk = trunkLength * t;

      const baseX = dTrunk.x * posOnTrunk;
      const baseY = dTrunk.y * posOnTrunk;

      let branchLength;
      if (reduction === 0) {
        branchLength = trunkLength;
      } else {
        branchLength = trunkLength * Math.pow(1 - reduction, i);
      }
      const branchWidth = branchLength * aspect;

      for (const sign of signs) {
        const branchAngle = trunkAngle + sign * angleOffset;
        segments.push({
          bx: baseX, by: baseY,
          length: branchLength,
          width: branchWidth,
          angle: branchAngle,
          tipMode,
          tipScale,
          isTrunk: false
        });

        const dBranch = { x: Math.cos(branchAngle), y: Math.sin(branchAngle) };

        for (let j = 1; j <= count; j++) {
          const t2 = j * spacing / 100.0;
          const posOnBranch = branchLength * t2;

          const twigBaseX = baseX + dBranch.x * posOnBranch;
          const twigBaseY = baseY + dBranch.y * posOnBranch;

          let twigLength;
          if (reduction === 0) {
            twigLength = branchLength;
          } else {
            twigLength = branchLength * Math.pow(1 - reduction, j);
          }
          const twigWidth = twigLength * aspect;

          for (const sign2 of signs) {
            const twigAngle = branchAngle + sign2 * angleOffset;
            segments.push({
              bx: twigBaseX, by: twigBaseY,
              length: twigLength,
              width: twigWidth,
              angle: twigAngle,
              tipMode,
              tipScale,
              isTrunk: false
            });
          }
        }
      }
    }

    return segments;
  }

  function buildSnowflakeSegments(params) {
    const baseSegs = buildSingleTreeSegments(params);
    const arms = Math.max(3, params.armCount);
    const all = [];
    const twoPi = 2 * Math.PI;

    for (let k = 0; k < arms; k++) {
      const phi = twoPi * k / arms;
      const cosP = Math.cos(phi);
      const sinP = Math.sin(phi);

      for (const s of baseSegs) {
        const x = s.bx;
        const y = s.by;
        const rx = x * cosP - y * sinP;
        const ry = x * sinP + y * cosP;

        all.push({
          bx: rx,
          by: ry,
          length: s.length,
          width: s.width,
          angle: s.angle + phi,
          tipMode: s.tipMode,
          tipScale: s.tipScale,
          isTrunk: s.isTrunk
        });
      }
    }
    return all;
  }

  function buildTentHexFromEdge(p1, p2, dir, tipScale) {
    const dxB = p2[0] - p1[0];
    const dyB = p2[1] - p1[1];
    const b = Math.hypot(dxB, dyB);
    if (b <= 1e-9) return null;

    const baseDir = { x: dxB / b, y: dyB / b };
    const sqrt3 = Math.sqrt(3);
    const h = b / (2 * sqrt3);
    const midX = (p1[0] + p2[0]) * 0.5;
    const midY = (p1[1] + p2[1]) * 0.5;
    const apexX = midX + dir.x * h;
    const apexY = midY + dir.y * h;

    const A = p1;
    const B = p2;
    const C = [apexX, apexY];

    const v = { x: C[0] - A[0], y: C[1] - A[1] };
    const dot = v.x * baseDir.x + v.y * baseDir.y;
    const v_par = { x: baseDir.x * dot, y: baseDir.y * dot };
    const v_perp = { x: v.x - v_par.x, y: v.y - v_par.y };
    const C_ref = [ C[0] - 2 * v_perp.x, C[1] - 2 * v_perp.y ];

    const sLen = Math.hypot(C[0] - A[0], C[1] - A[1]);
    const t = { x: -dir.x * sLen, y: -dir.y * sLen };

    const A2 = [ A[0] + t.x, A[1] + t.y ];
    const B2 = [ B[0] + t.x, B[1] + t.y ];
    const C2 = [ C_ref[0] + t.x, C_ref[1] + t.y ];

    const pts = [A, B, C, A2, B2, C2].map(p => [p[0], p[1]]);

    let cx = 0, cy = 0;
    for (const [x, y] of pts) {
      cx += x; cy += y;
    }
    cx /= pts.length;
    cy /= pts.length;

    pts.sort((p, q) => {
      const angP = Math.atan2(p[1] - cy, p[0] - cx);
      const angQ = Math.atan2(q[1] - cy, q[0] - cx);
      return angP - angQ;
    });

    const hexPoly = pts.slice();
    hexPoly.push(hexPoly[0].slice());
    return scalePolygon(hexPoly, tipScale);
  }

  function buildRegularHexFromEdge(p1, p2, dir, tipScale) {
    const dxB = p2[0] - p1[0];
    const dyB = p2[1] - p1[1];
    const b = Math.hypot(dxB, dyB);
    if (b <= 1e-9) return null;

    const wdir = { x: dxB / b, y: dyB / b };
    const midX = (p1[0] + p2[0]) * 0.5;
    const midY = (p1[1] + p2[1]) * 0.5;
    const sqrt3 = Math.sqrt(3);

    const local = [
      [-b/2, 0],
      [ b/2, 0],
      [ b,   (sqrt3/2)*b ],
      [ b/2,  sqrt3*b    ],
      [-b/2,  sqrt3*b    ],
      [-b,   (sqrt3/2)*b ]
    ];

    function toWorld(X, Y) {
      return [
        midX + X * wdir.x + Y * dir.x,
        midY + X * wdir.y + Y * dir.y
      ];
    }

    const hexPoly = local.map(([X,Y]) => toWorld(X,Y));
    hexPoly.push(hexPoly[0].slice());
    return scalePolygon(hexPoly, tipScale);
  }

  function buildTrapHexFromEdge(p1, p2, dir, tipScale) {
    const dxB = p2[0] - p1[0];
    const dyB = p2[1] - p1[1];
    const b = Math.hypot(dxB, dyB);
    if (b <= 1e-9) return null;

    const wdir = { x: dxB / b, y: dyB / b };
    const midX = (p1[0] + p2[0]) * 0.5;
    const midY = (p1[1] + p2[1]) * 0.5;
    const sqrt3 = Math.sqrt(3);

    const h = (sqrt3 / 4) * b;
    const halfTop = b / 4;

    const local = [
      [ b/2,     0   ],
      [ halfTop, h   ],
      [-halfTop, h   ],
      [-b/2,     0   ],
      [-halfTop,-h   ],
      [ halfTop,-h   ]
    ];

    function toWorld(X, Y) {
      return [
        midX + X * wdir.x + Y * dir.x,
        midY + X * wdir.y + Y * dir.y
      ];
    }

    const hexTrapPoly = local.map(([X,Y]) => toWorld(X,Y));
    hexTrapPoly.push(hexTrapPoly[0].slice());
    return scalePolygon(hexTrapPoly, tipScale);
  }

  function segmentToPolys(seg, params) {
    const polys = [];
    const mainRect = makeRectFromBase(seg.bx, seg.by, seg.length, seg.width, seg.angle);

    const tipMode     = seg.tipMode;
    const tipScale    = (typeof seg.tipScale === 'number' && isFinite(seg.tipScale)) ? seg.tipScale : 1;
    const onlyTips    = !!params.tipOnly;
    const addBaseTips = !!params.tipAtCenter && !!seg.isTrunk;
    const showTrunk   = !!params.showTrunk;

    if (seg.isTrunk) {
      if (showTrunk) polys.push(mainRect);
    } else {
      if (!onlyTips) polys.push(mainRect);
    }

    if (tipMode === 0) return polys;

    const d = { x: Math.cos(seg.angle), y: Math.sin(seg.angle) };

    if (tipMode === 2) {
      function addYAt(baseX, baseY, mainAngle) {
        const capLength = seg.length * 0.3 * tipScale;
        const capWidth  = seg.width;
        const deltas = [Math.PI / 3, -Math.PI / 3];
        for (const delta of deltas) {
          const tipAngle = mainAngle + delta;
          polys.push(makeRectFromBase(baseX, baseY, capLength, capWidth, tipAngle));
        }
      }
      const tipBaseX = seg.bx + d.x * seg.length;
      const tipBaseY = seg.by + d.y * seg.length;
      addYAt(tipBaseX, tipBaseY, seg.angle);
      if (addBaseTips) {
        addYAt(seg.bx, seg.by, seg.angle + Math.PI);
      }
      return polys;
    }

    const p1_far  = mainRect[0];
    const p2_far  = mainRect[1];
    const p1_near = mainRect[3];
    const p2_near = mainRect[2];

    const dTop  = d;
    const dBase = { x: -d.x, y: -d.y };

    if (tipMode === 1) {
      const hexTop = buildTentHexFromEdge(p1_far,  p2_far,  dTop,  tipScale);
      if (hexTop) polys.push(hexTop);
      if (addBaseTips) {
        const hexBase = buildTentHexFromEdge(p1_near, p2_near, dBase, tipScale);
        if (hexBase) polys.push(hexBase);
      }
    } else if (tipMode === 3) {
      const hexTop = buildRegularHexFromEdge(p1_far,  p2_far,  dTop,  tipScale);
      if (hexTop) polys.push(hexTop);
      if (addBaseTips) {
        const hexBase = buildRegularHexFromEdge(p1_near, p2_near, dBase, tipScale);
        if (hexBase) polys.push(hexBase);
      }
    } else if (tipMode === 4) {
      const hexTop = buildTrapHexFromEdge(p1_far,  p2_far,  dTop,  tipScale);
      if (hexTop) polys.push(hexTop);
      if (addBaseTips) {
        const hexBase = buildTrapHexFromEdge(p1_near, p2_near, dBase, tipScale);
        if (hexBase) polys.push(hexBase);
      }
    }

    return polys;
  }

  function pointInPolygon(x, y, poly) {
    let inside = false;
    const n = poly.length;
    for (let i = 0, j = n - 1; i < n; j = i++) {
      const xi = poly[i][0], yi = poly[i][1];
      const xj = poly[j][0], yj = poly[j][1];
      const intersect = ((yi > y) !== (yj > y)) &&
                        (x < (xj - xi) * (y - yi) / (yj - yi + 1e-12) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  function buildLaserContoursExact(scaledPolys) {
    if (!scaledPolys || !scaledPolys.length) return [];

    const EPS = 1e-9;

    const polyInfos = scaledPolys.map(poly => {
      const unique = poly.slice(0, poly.length - 1);
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;
      for (const [x,y] of unique) {
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }
      return { poly, unique, minX, maxX, minY, maxY };
    });

    function pointInAnyPoly(x, y) {
      for (const info of polyInfos) {
        if (x < info.minX - 1e-6 || x > info.maxX + 1e-6 ||
            y < info.minY - 1e-6 || y > info.maxY + 1e-6) continue;
        if (pointInPolygon(x, y, info.poly)) return true;
      }
      return false;
    }

    const edges = [];
    for (let pi = 0; pi < scaledPolys.length; pi++) {
      const poly = scaledPolys[pi];
      const unique = poly.slice(0, poly.length - 1);
      const n = unique.length;
      if (n < 2) continue;
      for (let i = 0; i < n; i++) {
        const a = unique[i];
        const b = unique[(i + 1) % n];
        edges.push({
          ax: a[0], ay: a[1],
          bx: b[0], by: b[1],
          polyIndex: pi,
          splitTs: [0, 1]
        });
      }
    }

    function addParam(arr, t) {
      if (t < -EPS || t > 1 + EPS) return;
      t = Math.max(0, Math.min(1, t));
      for (let i = 0; i < arr.length; i++) {
        if (Math.abs(arr[i] - t) < 1e-6) return;
      }
      arr.push(t);
    }

    function intersectEdges(e1, e2) {
      const p = { x: e1.ax, y: e1.ay };
      const r = { x: e1.bx - e1.ax, y: e1.by - e1.ay };
      const q = { x: e2.ax, y: e2.ay };
      const s = { x: e2.bx - e2.ax, y: e2.by - e2.ay };

      const rxs = r.x * s.y - r.y * s.x;
      const qmp = { x: q.x - p.x, y: q.y - p.y };
      const qpxr = qmp.x * r.y - qmp.y * r.x;
      const rr = r.x * r.x + r.y * r.y;
      const ss = s.x * s.x + s.y * s.y;

      if (Math.abs(rxs) < 1e-9) {
        if (Math.abs(qpxr) > 1e-9) return;

        const t0 = ( (q.x - p.x) * r.x + (q.y - p.y) * r.y ) / rr;
        const t1 = ( (q.x + s.x - p.x) * r.x + (q.y + s.y - p.y) * r.y ) / rr;

        const tmin = Math.max(0, Math.min(t0, t1));
        const tmax = Math.min(1, Math.max(t0, t1));
        if (tmax < -1e-9 || tmin > 1 + 1e-9 || tmax - tmin < 1e-9) return;

        addParam(e1.splitTs, tmin);
        addParam(e1.splitTs, tmax);

        const u0 = ( (p.x - q.x) * s.x + (p.y - q.y) * s.y ) / ss;
        const u1 = ( (p.x + r.x - q.x) * s.x + (p.y + r.y - q.y) * s.y ) / ss;
        const umin = Math.max(0, Math.min(u0, u1));
        const umax = Math.min(1, Math.max(u0, u1));
        if (umax < -1e-9 || umin > 1 + 1e-9 || umax - umin < 1e-9) return;

        addParam(e2.splitTs, umin);
      } else {
        const t = (qmp.x * s.y - qmp.y * s.x) / rxs;
        const u = (qmp.x * r.y - qmp.y * r.x) / rxs;
        if (t >= -1e-9 && t <= 1 + 1e-9 && u >= -1e-9 && u <= 1 + 1e-9) {
          addParam(e1.splitTs, t);
          addParam(e2.splitTs, u);
        }
      }
    }

    for (let i = 0; i < edges.length; i++) {
      for (let j = i + 1; j < edges.length; j++) {
        intersectEdges(edges[i], edges[j]);
      }
    }

    const rawSegments = [];
    for (const e of edges) {
      const { ax, ay, bx, by, splitTs } = e;
      splitTs.sort((a, b) => a - b);
      for (let k = 0; k < splitTs.length - 1; k++) {
        const t0 = splitTs[k];
        const t1 = splitTs[k + 1];
        if (t1 - t0 < 1e-5) continue;
        const x0 = ax + (bx - ax) * t0;
        const y0 = ay + (by - ay) * t0;
        const x1 = ax + (bx - ax) * t1;
        const y1 = ay + (by - ay) * t1;
        rawSegments.push({ x0, y0, x1, y1 });
      }
    }

    const boundarySegments = [];
    for (const seg of rawSegments) {
      const dx = seg.x1 - seg.x0;
      const dy = seg.y1 - seg.y0;
      const len = Math.hypot(dx, dy);
      if (len < 1e-4) continue;
      const mx = 0.5 * (seg.x0 + seg.x1);
      const my = 0.5 * (seg.y0 + seg.y1);
      const nx = -dy / len;
      const ny =  dx / len;
      const off = 1e-3;

      const px1 = mx + nx * off;
      const py1 = my + ny * off;
      const px2 = mx - nx * off;
      const py2 = my - ny * off;

      const inside1 = pointInAnyPoly(px1, py1);
      const inside2 = pointInAnyPoly(px2, py2);

      if (inside1 !== inside2) {
        boundarySegments.push(seg);
      }
    }

    const pointKey = (x, y) => x.toFixed(4) + ',' + y.toFixed(4);
    const adjacency = new Map();

    function addEdgeAdj(x0, y0, x1, y1) {
      const k0 = pointKey(x0, y0);
      const k1 = pointKey(x1, y1);

      if (!adjacency.has(k0)) adjacency.set(k0, { pt: [x0, y0], neighbors: new Set() });
      if (!adjacency.has(k1)) adjacency.set(k1, { pt: [x1, y1], neighbors: new Set() });

      adjacency.get(k0).neighbors.add(k1);
      adjacency.get(k1).neighbors.add(k0);
    }
    for (const seg of boundarySegments) {
      addEdgeAdj(seg.x0, seg.y0, seg.x1, seg.y1);
    }

    const visited = new Set();
    const contours = [];

    for (const [key, node] of adjacency.entries()) {
      if (visited.has(key)) continue;

      const contour = [];
      let currentKey = key;
      let prevKey = null;

      while (currentKey && !visited.has(currentKey)) {
        visited.add(currentKey);
        const currentNode = adjacency.get(currentKey);
        contour.push(currentNode.pt);

        const neighbors = Array.from(currentNode.neighbors);
        let nextKey = null;
        for (const nk of neighbors) {
          if (nk !== prevKey) {
            nextKey = nk;
            if (!visited.has(nk)) break;
          }
        }
        prevKey = currentKey;
        currentKey = nextKey;
        if (!currentKey || currentKey === key) break;
      }

      if (contour.length >= 3) {
        if (contour[0] !== contour[contour.length - 1]) {
          contour.push(contour[0].slice());
        }
        contours.push(contour);
      }
    }

    return contours;
  }

  function computeContoursForCode(codeString) {
    if (geometryCache.has(codeString)) {
      return geometryCache.get(codeString);
    }

    const params = paramsFromCode(codeString);
    const segments = buildSnowflakeSegments(params);
    if (!segments.length) return null;

    let minX0 = Infinity, maxX0 = -Infinity;
    let minY0 = Infinity, maxY0 = -Infinity;

    for (const seg of segments) {
      const polys = segmentToPolys(seg, params);
      for (const poly of polys) {
        for (const [x,y] of poly) {
          if (x < minX0) minX0 = x;
          if (x > maxX0) maxX0 = x;
          if (y < minY0) minY0 = y;
          if (y > maxY0) maxY0 = y;
        }
      }
    }

    const width0  = maxX0 - minX0 || 1;
    const height0 = maxY0 - minY0 || 1;
    const size0   = Math.max(width0, height0) || 1;

    const scaleModelToMm = DXF_TARGET_SIZE / size0;
    const minRectMm  = Math.max(0, params.minRectMm || 0);
    const growSmall  = params.growSmallRects;
    const minWidthModel = minRectMm > 0 ? (minRectMm / scaleModelToMm) : 0;

    const adjustedSegments = [];
    for (const seg of segments) {
      if (minWidthModel <= 0) {
        adjustedSegments.push(seg);
      } else if (seg.width >= minWidthModel) {
        adjustedSegments.push(seg);
      } else if (growSmall) {
        adjustedSegments.push({ ...seg, width: minWidthModel });
      }
    }
    if (!adjustedSegments.length) return null;

    const rects = [];
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;

    for (const seg of adjustedSegments) {
      const polys = segmentToPolys(seg, params);
      for (const poly of polys) {
        rects.push(poly);
        for (const [x,y] of poly) {
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
          if (y < minY) minY = y;
          if (y > maxY) maxY = y;
        }
      }
    }

    const width  = maxX - minX || 1;
    const height = maxY - minY || 1;
    const size   = Math.max(width, height) || 1;
    const scale  = DXF_TARGET_SIZE / size;

    const scaledPolys = rects.map(poly =>
      poly.map(([x,y]) => [ (x - minX) * scale, (y - minY) * scale ])
    );

    const contours = buildLaserContoursExact(scaledPolys);
    if (!contours.length) return null;

    let outerIndex = 0;
    let maxAbsArea = -1;
    for (let i = 0; i < contours.length; i++) {
      const contour = contours[i];
      const unique = contour.slice(0, contour.length - 1);
      if (unique.length < 3) continue;
      let area = 0;
      for (let j = 0, k = unique.length - 1; j < unique.length; k = j++) {
        const xi = unique[j][0], yi = unique[j][1];
        const xj = unique[k][0], yj = unique[k][1];
        area += (xj * yi - xi * yj);
      }
      area *= 0.5;
      const absArea = Math.abs(area);
      if (absArea > maxAbsArea) {
        maxAbsArea = absArea;
        outerIndex = i;
      }
    }

    const contoursWithFlags = contours.map((c, idx) => ({
      points: c,
      isOuter: idx === outerIndex
    }));

    const result = { contoursWithFlags };
    geometryCache.set(codeString, result);
    return result;
  }

  function computePolysForCode(codeString) {
    const params = paramsFromCode(codeString);
    const segments = buildSnowflakeSegments(params);
    if (!segments.length) return null;

    let minX0 = Infinity, maxX0 = -Infinity;
    let minY0 = Infinity, maxY0 = -Infinity;

    for (const seg of segments) {
      const polys = segmentToPolys(seg, params);
      for (const poly of polys) {
        for (const [x,y] of poly) {
          if (x < minX0) minX0 = x;
          if (x > maxX0) maxX0 = x;
          if (y < minY0) minY0 = y;
          if (y > maxY0) maxY0 = y;
        }
      }
    }

    const width0  = maxX0 - minX0 || 1;
    const height0 = maxY0 - minY0 || 1;
    const size0   = Math.max(width0, height0) || 1;

    const scaleModelToMm = DXF_TARGET_SIZE / size0;
    const minRectMm  = Math.max(0, params.minRectMm || 0);
    const growSmall  = params.growSmallRects;
    const minWidthModel = minRectMm > 0 ? (minRectMm / scaleModelToMm) : 0;

    const adjustedSegments = [];
    for (const seg of segments) {
      if (minWidthModel <= 0) {
        adjustedSegments.push(seg);
      } else if (seg.width >= minWidthModel) {
        adjustedSegments.push(seg);
      } else if (growSmall) {
        adjustedSegments.push({ ...seg, width: minWidthModel });
      }
    }
    if (!adjustedSegments.length) return null;

    const rects = [];
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;

    for (const seg of adjustedSegments) {
      const polys = segmentToPolys(seg, params);
      for (const poly of polys) {
        rects.push(poly);
        for (const [x,y] of poly) {
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
          if (y < minY) minY = y;
          if (y > maxY) maxY = y;
        }
      }
    }

    const width  = maxX - minX || 1;
    const height = maxY - minY || 1;
    const size   = Math.max(width, height) || 1;
    const scale  = DXF_TARGET_SIZE / size;

    const scaledPolys = rects.map(poly =>
      poly.map(([x,y]) => [ (x - minX) * scale, (y - minY) * scale ])
    );

    return {
      polys: scaledPolys,
      minX: 0,
      maxX: width * scale,
      minY: 0,
      maxY: height * scale
    };
  }

  function addJpegCommentToArrayBuffer(arrayBuffer, comment) {
    const bytes = new Uint8Array(arrayBuffer);
    if (bytes.length < 4 || bytes[0] !== 0xFF || bytes[1] !== 0xD8) {
      return new Blob([bytes], { type: 'image/jpeg' });
    }
    const encoder = new TextEncoder();
    const commentBytes = encoder.encode(comment);
    const len = commentBytes.length + 2;

    const newBytes = new Uint8Array(bytes.length + commentBytes.length + 4);
    let offset = 0;

    newBytes[offset++] = 0xFF;
    newBytes[offset++] = 0xD8;

    newBytes[offset++] = 0xFF;
    newBytes[offset++] = 0xFE;
    newBytes[offset++] = (len >> 8) & 0xFF;
    newBytes[offset++] = len & 0xFF;

    newBytes.set(commentBytes, offset);
    offset += commentBytes.length;

    newBytes.set(bytes.subarray(2), offset);

    return new Blob([newBytes], { type: 'image/jpeg' });
  }

  function createJpegBlobForCode(code) {
    const polyData = computePolysForCode(code);
    if (!polyData) return Promise.resolve(null);
    const { polys, minX, maxX, minY, maxY } = polyData;

    const canvas = document.createElement('canvas');
    canvas.width  = 600;
    canvas.height = 640;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#001633';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const width  = maxX - minX || 1;
    const height = maxY - minY || 1;

    const marginX   = 40;
    const topMargin = 40;
    const textSpace = 70;
    const drawWidth  = canvas.width - 2 * marginX;
    const drawHeight = canvas.height - topMargin - textSpace;

    const scale  = 0.95 * Math.min(drawWidth / width, drawHeight / height);
    const cx     = (minX + maxX) / 2;
    const cy     = (minY + maxY) / 2;
    const originX = canvas.width / 2;
    const originY = topMargin + drawHeight / 2;

    const fillColor   = '#bfe9ff';
    const strokeColor = fillColor;

    ctx.lineJoin    = 'round';
    ctx.lineCap     = 'round';
    ctx.lineWidth   = 1.2;
    ctx.fillStyle   = fillColor;
    ctx.strokeStyle = strokeColor;

    for (const poly of polys) {
      if (!poly || poly.length < 2) continue;
      ctx.beginPath();
      for (let i = 0; i < poly.length; i++) {
        const x = poly[i][0];
        const y = poly[i][1];
        const sx = originX + (x - cx) * scale;
        const sy = originY - (y - cy) * scale;
        if (i === 0) ctx.moveTo(sx, sy);
        else ctx.lineTo(sx, sy);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }

    ctx.fillStyle = '#ffffff';
    ctx.font = '16px system-ui, -apple-system, BlinkMacSystemFont,"Segoe UI",sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(code, canvas.width / 2, canvas.height - textSpace / 2);

    return new Promise((resolve) => {
      canvas.toBlob((blob) => {
        if (!blob) {
          resolve(null);
          return;
        }
        const reader = new FileReader();
        reader.onload = (e) => {
          const arr = e.target.result;
          const commentedBlob = addJpegCommentToArrayBuffer(arr, 'PEHELY-' + code);
          resolve(commentedBlob);
        };
        reader.readAsArrayBuffer(blob);
      }, 'image/jpeg', 0.92);
    });
  }

  function parseCodeFromJpegArrayBuffer(arrayBuffer) {
    const bytes = new Uint8Array(arrayBuffer);
    if (bytes.length < 4 || bytes[0] !== 0xFF || bytes[1] !== 0xD8) return null;

    let i = 2;
    while (i + 4 <= bytes.length) {
      if (bytes[i] !== 0xFF) { i++; continue; }
      const marker = bytes[i + 1];
      if (marker === 0xD9 || marker === 0xDA) break;
      const len = (bytes[i + 2] << 8) | bytes[i + 3];
      if (len < 2 || i + 2 + len > bytes.length) break;

      if (marker === 0xFE) {
        const start = i + 4;
        const end   = i + 2 + len;
        const comBytes = bytes.subarray(start, end);
        const decoder  = new TextDecoder('utf-8');
        const text     = decoder.decode(comBytes);
        const idx      = text.indexOf('PEHELY-');
        if (idx !== -1) {
          const code = text.substring(idx + 7).trim();
          if (code) return code;
        }
      }
      i += 2 + len;
    }
    return null;
  }

  async function readCodeFromJpegFileHandle(fileHandle) {
    const file = await fileHandle.getFile();
    const arrayBuffer = await file.arrayBuffer();
    return parseCodeFromJpegArrayBuffer(arrayBuffer);
  }

  // ====== HAVAZO adatszerkezetek ======

  let currentDirectoryHandle = null;
  const cardsGrid = document.getElementById('cardsGrid');
  const emptyMessage = document.getElementById('emptyMessage');
  const currentFolderNameEl = document.getElementById('currentFolderName');

  let items = [];                // { code, fileHandle|null, imgURL, quantity, isVirtual, cardElem, qtyInput }
  const itemsByCode = new Map(); // code -> item
  const quantitiesFromJson = new Map(); // code -> count (0 is megőrződik)

  // Summary elemek
  const summaryAllTypesEl      = document.getElementById('summaryAllTypes');
  const summarySelectedTypesEl = document.getElementById('summarySelectedTypes');
  const summaryTotalPiecesEl   = document.getElementById('summaryTotalPieces');

  function updateSummaryCounts() {
    // összes típus a mappában: olyan itemek, amelyeknek van valódi fileHandle-je
    const totalFolderTypes = items.filter(it => !!it.fileHandle).length;

    // kiválasztott típusok: item.quantity > 0
    let selectedTypes = 0;
    let totalPieces = 0;
    for (const it of items) {
      const q = Number.isFinite(it.quantity) ? it.quantity : 0;
      if (q > 0) selectedTypes++;
      totalPieces += Math.max(0, q);
    }

    summaryAllTypesEl.textContent      = totalFolderTypes.toString();
    summarySelectedTypesEl.textContent = selectedTypes.toString();
    summaryTotalPiecesEl.textContent   = totalPieces.toString();
  }

  // ====== Kártyák + overlay ======

  const previewOverlay = document.getElementById('previewOverlay');
  const previewImage   = document.getElementById('previewImage');
  const previewCodeEl  = document.getElementById('previewCode');
  const previewCloseBtn= document.getElementById('previewCloseBtn');
  const previewContent = document.getElementById('previewContent');

  function openPreviewForItem(item) {
    if (!item || !item.imgURL) return;
    previewImage.src = item.imgURL;
    previewCodeEl.textContent = 'PEHELY-' + item.code;
    previewOverlay.classList.add('active');
  }

  function closePreview() {
    previewOverlay.classList.remove('active');
  }

  previewCloseBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    closePreview();
  });
  previewOverlay.addEventListener('click', () => {
    closePreview();
  });
  previewContent.addEventListener('click', (e) => {
    e.stopPropagation();
  });
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') closePreview();
  });

  function createCardForItem(item) {
    const card = document.createElement('div');
    card.className = 'snowflake-card';

    const thumbWrap = document.createElement('div');
    thumbWrap.className = 'thumb-wrapper';

    const img = document.createElement('img');
    img.src = item.imgURL;
    img.alt = 'Hópehely';

    thumbWrap.appendChild(img);
    card.appendChild(thumbWrap);

    const qtyRow = document.createElement('div');
    qtyRow.className = 'qty-row';

    const qtyInput = document.createElement('input');
    qtyInput.type = 'number';
    qtyInput.min = '0';
    qtyInput.step = '1';
    qtyInput.value = item.quantity.toString();

    const dbSpan = document.createElement('span');
    dbSpan.textContent = 'db';

    qtyRow.appendChild(qtyInput);
    qtyRow.appendChild(dbSpan);
    card.appendChild(qtyRow);

    qtyInput.addEventListener('click', (e) => {
      e.stopPropagation();
    });
    qtyInput.addEventListener('change', () => {
      let v = parseInt(qtyInput.value, 10);
      if (!Number.isFinite(v) || v < 0) v = 0;
      qtyInput.value = v.toString();
      item.quantity = v;
      quantitiesFromJson.set(item.code, v);
      updateSummaryCounts();
    });

    card.addEventListener('click', () => {
      openPreviewForItem(item);
    });

    item.cardElem = card;
    item.qtyInput = qtyInput;
    return card;
  }

  function refreshCardsGrid() {
    cardsGrid.innerHTML = '';
    if (!items.length) {
      emptyMessage.style.display = 'block';
      updateSummaryCounts();
      return;
    }
    emptyMessage.style.display = 'none';
    for (const item of items) {
      const card = createCardForItem(item);
      cardsGrid.appendChild(card);
    }
    updateSummaryCounts();
  }

  // ====== Mappa beolvasása ======

  async function pickFolderAndScan() {
    if (!window.showDirectoryPicker) {
      alert('A mappa kijelöléséhez szükséges File System Access API nem érhető el ebben a böngészőben.');
      return;
    }
    try {
      const handle = await window.showDirectoryPicker();
      currentDirectoryHandle = handle;
      currentFolderNameEl.textContent = handle.name;
      await scanCurrentFolder();
    } catch (e) {
      console.warn('Mappa kijelölése megszakítva vagy hiba:', e);
    }
  }

  async function scanCurrentFolder() {
    items = [];
    itemsByCode.clear();
    cardsGrid.innerHTML = '';
    emptyMessage.style.display = 'block';

    if (!currentDirectoryHandle) {
      updateSummaryCounts();
      return;
    }

    try {
      for await (const entry of currentDirectoryHandle.values()) {
        if (entry.kind === 'file' &&
            entry.name.toLowerCase().endsWith('.jpg')) {

          const code = await readCodeFromJpegFileHandle(entry);
          if (!code) continue;

          if (itemsByCode.has(code)) continue;

          const file = await entry.getFile();
          const url = URL.createObjectURL(file);
          const qty = quantitiesFromJson.has(code) ? quantitiesFromJson.get(code) : 1;

          const item = {
            code,
            fileHandle: entry,
            imgURL: url,
            quantity: qty,
            isVirtual: false,
            cardElem: null,
            qtyInput: null
          };
          items.push(item);
          itemsByCode.set(code, item);
        }
      }
    } catch (e) {
      console.error('Hiba a mappa olvasása közben:', e);
    }

    for (const [code, qty] of quantitiesFromJson.entries()) {
      if (!itemsByCode.has(code)) {
        try {
          const blob = await createJpegBlobForCode(code);
          if (!blob) continue;
          const url = URL.createObjectURL(blob);
          const item = {
            code,
            fileHandle: null,
            imgURL: url,
            quantity: qty,
            isVirtual: true,
            cardElem: null,
            qtyInput: null
          };
          items.push(item);
          itemsByCode.set(code, item);
        } catch (e) {
          console.error('Virtuális kép generálási hiba:', e);
        }
      }
    }

    refreshCardsGrid();
  }

  // ====== Lista betöltése (JSON) ======

  async function loadListFromJson() {
    if (!window.showOpenFilePicker) {
      alert('A lista betöltéséhez szükséges File System Access API nem érhető el ebben a böngészőben.');
      return;
    }
    try {
      const [handle] = await window.showOpenFilePicker({
        types: [{
          description: 'HAVAZO lista (JSON)',
          accept: { 'application/json': ['.json'] }
        }]
      });
      const file = await handle.getFile();
      const text = await file.text();
      const data = JSON.parse(text);

      quantitiesFromJson.clear();
      if (data && Array.isArray(data.items)) {
        for (const it of data.items) {
          if (!it || typeof it.code !== 'string') continue;
          const count = Number.isFinite(it.count) ? it.count : 0;
          quantitiesFromJson.set(it.code, count);
        }
      }

      await scanCurrentFolder();
    } catch (e) {
      console.warn('Lista betöltése megszakítva vagy hiba:', e);
    }
  }

  // ====== Hiányzó képek generálása ======

  async function generateMissingImages() {
    if (!quantitiesFromJson.size && !items.length) {
      alert('Nincs ismert hópehely-kód, amit generálni lehetne.');
      return;
    }

    const missingCodes = [];
    for (const [code] of quantitiesFromJson.entries()) {
      const item = itemsByCode.get(code);
      if (!item || !item.fileHandle) {
        missingCodes.push(code);
      }
    }

    for (const item of items) {
      if (item.isVirtual && !quantitiesFromJson.has(item.code)) {
        missingCodes.push(item.code);
      }
    }

    if (!missingCodes.length) {
      alert('Nincs hiányzó kép, minden hópehelyhez tartozik már JPG.');
      return;
    }

    for (const code of missingCodes) {
      try {
        const blob = await createJpegBlobForCode(code);
        if (!blob) continue;
        const filename = `PEHELY-${code}.jpg`;
        downloadBlob(blob, filename);
      } catch (e) {
        console.error('Hiba a kép generálásakor:', e);
      }
    }

    alert('A hiányzó képek JPG formátumban letöltésre kerültek. Helyezd őket a munkamappába, majd olvasd be újra a mappát, ha szükséges.');
  }

  // ====== Minden mennyiséget azonosra állító gomb ======

  function applyBulkQuantity() {
    let v = parseInt(document.getElementById('bulkQtyInput').value, 10);
    if (!Number.isFinite(v) || v < 0) v = 0;
    document.getElementById('bulkQtyInput').value = v.toString();

    for (const item of items) {
      item.quantity = v;
      if (item.qtyInput) item.qtyInput.value = v.toString();
      quantitiesFromJson.set(item.code, v);
    }
    updateSummaryCounts();
  }

  // ====== DXF + JSON mentés (MENTÉS gomb) ======

  function translateContour(contour, dx, dy) {
    const unique = contour.slice(0, contour.length - 1);
    const translated = unique.map(([x,y]) => [x + dx, y + dy]);
    translated.push(translated[0].slice());
    return translated;
  }

  async function saveAll() {
    if (!items.length && !quantitiesFromJson.size) {
      alert('Nincs menthető hópehely.');
      return;
    }

    const allCodesSet = new Set();
    for (const item of items) {
      allCodesSet.add(item.code);
      quantitiesFromJson.set(item.code,
        Number.isFinite(item.quantity) ? item.quantity : 0);
    }
    for (const [code] of quantitiesFromJson.entries()) {
      allCodesSet.add(code);
    }

    const allCodes = Array.from(allCodesSet);
    const codesWithCounts = [];
    let totalCount = 0;
    for (const code of allCodes) {
      const count = quantitiesFromJson.get(code) ?? 0;
      codesWithCounts.push({ code, count });
      totalCount += Math.max(0, count);
    }

    if (totalCount === 0) {
      if (!confirm('Minden hópehely darabszáma 0. Csak a listát (JSON) szeretnéd menteni?')) {
        return;
      }
    }

    const flakeData = [];
    let maxWidth = 0;
    let maxHeight = 0;

    for (const { code, count } of codesWithCounts) {
      if (count <= 0) continue;
      const geom = computeContoursForCode(code);
      if (!geom || !geom.contoursWithFlags.length) continue;

      const contours = geom.contoursWithFlags;
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;
      for (const c of contours) {
        const unique = c.points.slice(0, c.points.length - 1);
        for (const [x,y] of unique) {
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
          if (y < minY) minY = y;
          if (y > maxY) maxY = y;
        }
      }
      const width  = maxX - minX;
      const height = maxY - minY;
      maxWidth  = Math.max(maxWidth, width);
      maxHeight = Math.max(maxHeight, height);

      flakeData.push({ code, count, contours, minX, maxX, minY, maxY, width, height });
    }

    let dxfString = '';
    if (totalCount > 0 && flakeData.length > 0) {
      const gap = 2.0; // mm
      const cellSize = Math.max(maxWidth, maxHeight) + 2*gap;

      const cols = Math.ceil(Math.sqrt(totalCount));

      const NL = '\r\n';
      function add(code, value) {
        dxfString += code + NL + value + NL;
      }
      add(0, 'SECTION');
      add(2, 'HEADER');
      add(0, 'ENDSEC');
      add(0, 'SECTION');
      add(2, 'ENTITIES');

      let index = 0;
      for (const flake of flakeData) {
        const { count, contours, minX, maxX, minY, maxY } = flake;
        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY) / 2;

        for (let k = 0; k < count; k++) {
          const row = Math.floor(index / cols);
          const col = index % cols;
          index++;

          const baseX = col * cellSize;
          const baseY = row * cellSize;
          const cxCell = baseX + cellSize / 2;
          const cyCell = baseY + cellSize / 2;

          const dx = cxCell - cx;
          const dy = cyCell - cy;

          for (const c of contours) {
            const translated = translateContour(c.points, dx, dy);
            const unique = translated.slice(0, translated.length - 1);
            if (unique.length < 3) continue;

            add(0, 'LWPOLYLINE');
            add(8, '0');
            add(62, c.isOuter ? 7 : 5);
            add(90, unique.length);
            add(70, 1); // zárt

            for (const [x,y] of unique) {
              add(10, x.toFixed(4));
              add(20, y.toFixed(4));
            }
          }
        }
      }
      add(0, 'ENDSEC');
      add(0, 'EOF');
    }

    const now = new Date();
    const baseName = 'HAVAZO_' + formatTimestampForName(now);

    if (dxfString) {
      await saveWithPickerOrDownload(baseName + '.dxf', 'application/dxf', dxfString);
    }

    const jsonData = {
      version: 'HAVAZO_V10',
      generatedAt: now.toISOString(),
      items: codesWithCounts
    };
    const jsonText = JSON.stringify(jsonData, null, 2);
    await saveWithPickerOrDownload(baseName + '.json', 'application/json', jsonText);

    alert('Mentés kész: DXF és JSON létrehozva (ahol engedélyezve volt).');
  }

  // ====== Init ======
  window.addEventListener('load', () => {
    document.getElementById('chooseFolderBtn')
      .addEventListener('click', pickFolderAndScan);
    document.getElementById('loadListBtn')
      .addEventListener('click', loadListFromJson);
    document.getElementById('generateMissingBtn')
      .addEventListener('click', generateMissingImages);
    document.getElementById('bulkApplyBtn')
      .addEventListener('click', applyBulkQuantity);
    document.getElementById('saveAllBtn')
      .addEventListener('click', saveAll);

    // induláskor is nullázzuk az összesítőket
    updateSummaryCounts();
  });
</script>
</body>
</html>
