<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8">
  <title>Rodé Lajos - Hópehely generátor</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body {
      margin: 0;
      padding: 0;
      background: #f2f4f8;
      color: #222;
    }
    h1 {
      font-size: 1.4rem;
      margin: 0 0 0.5rem 0;
    }
    h2 {
      font-size: 1rem;
      margin-top: 0;
    }
    .page {
      max-width: 1100px;
      margin: 0 auto;
      padding: 1rem;
    }
    .container {
      display: flex;
      gap: 1rem;
      align-items: stretch;
    }
    .controls {
      flex: 0 0 360px;
      background: #fff;
      border-radius: 8px;
      padding: 0.8rem 1rem 1rem;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    }
    .canvas-container {
      flex: 1;
      background: #001633;
      border-radius: 8px;
      padding: 0.5rem;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .control-group {
      margin-bottom: 0.8rem;
    }
    .control-group label {
      display: block;
      font-size: 0.85rem;
      margin-bottom: 0.2rem;
    }
    .control-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .control-row input[type="range"] {
      flex: 1;
    }
    .control-row input[type="number"] {
      width: 4.5rem;
      padding: 0.1rem 0.2rem;
    }
    select {
      width: 100%;
      padding: 0.15rem 0.2rem;
      font-size: 0.85rem;
    }
    .separator {
      text-align: center;
      color: #888;
      font-size: 0.8rem;
      margin: 0.4rem 0;
    }
    .buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    button {
      flex: 1 1 48%;
      padding: 0.35rem 0.6rem;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      transition: background 0.15s, box-shadow 0.15s, transform 0.05s;
    }
    button.primary {
      background: #0d6efd;
      color: #fff;
    }
    button.secondary {
      background: #e9ecef;
      color: #222;
    }
    button:hover {
      box-shadow: 0 1px 4px rgba(0,0,0,0.18);
    }
    button:active {
      transform: translateY(1px);
      box-shadow: 0 0 0 rgba(0,0,0,0);
    }
    canvas {
      border-radius: 8px;
      background: #001633;
      box-shadow: inset 0 0 6px rgba(0,0,0,0.4);
    }
    .note {
      font-size: 0.75rem;
      margin-top: 0.4rem;
      color: #555;
    }
    @media (max-width: 900px) {
      .container {
        flex-direction: column;
      }
      .controls {
        flex: none;
        width: 100%;
      }
    }
  </style>
</head>
<body>
<div class="page">
  <h1>Rodé Lajos - Hópehely generátor</h1>

  <div class="container">
    <div class="controls">
      <h2>Paraméterek</h2>

      <div class="control-group">
        <label for="angleSlider">Szög (°)</label>
        <div class="control-row">
          <input id="angleSlider" type="range" min="10" max="120" step="1" value="30">
          <input id="angleInput" type="number" min="10" max="120" step="1" value="30">
        </div>
      </div>

      <div class="control-group">
        <label for="ratioSlider">Vastagság (%)</label>
        <div class="control-row">
          <input id="ratioSlider" type="range" min="5" max="40" step="1" value="20">
          <input id="ratioInput" type="number" min="5" max="40" step="1" value="20">
        </div>
      </div>

      <div class="control-group">
        <label for="spacingSlider">Köz (%)</label>
        <div class="control-row">
          <input id="spacingSlider" type="range" min="10" max="50" step="1" value="30">
          <input id="spacingInput" type="number" min="10" max="50" step="1" value="30">
        </div>
      </div>

      <div class="control-group">
        <label for="reductionSlider">Méretcsökkenés (%)</label>
        <div class="control-row">
          <input id="reductionSlider" type="range" min="0" max="70" step="1" value="40">
          <input id="reductionInput" type="number" min="0" max="70" step="1" value="40">
        </div>
      </div>

      <div class="control-group">
        <label for="tipStyleSelect">Végforma</label>
        <select id="tipStyleSelect">
          <option value="straight">Egyenes</option>
          <option value="tent">Háromszög</option>
          <option value="trap">Trapéz</option>
          <option value="hex">Hatszög</option>
          <option value="Y">Y</option>
        </select>
      </div>

      <div class="separator">-------------</div>

      <div class="control-group">
        <label for="armsSlider">Karok száma</label>
        <div class="control-row">
          <input id="armsSlider" type="range" min="3" max="12" step="1" value="6">
          <input id="armsInput" type="number" min="3" max="12" step="1" value="6">
        </div>
      </div>

      <div class="separator">-------------</div>

      <div class="control-group">
        <label for="minRectSlider">Min. vastagság (mm)</label>
        <div class="control-row">
          <input id="minRectSlider" type="range" min="0" max="10" step="0.1" value="0">
          <input id="minRectInput" type="number" min="0" max="10" step="0.1" value="0">
        </div>
      </div>

      <div class="control-group">
        <label>
          <input type="checkbox" id="growSmallCheckbox">
          Kisebbek növelése
        </label>
      </div>

      <div class="buttons">
        <button id="randomBtn" class="secondary">Véletlen paraméterek</button>
        <button id="toggleOutlineBtn" class="secondary">Kontúr ki/be</button>
        <button id="exportSolidBtn" class="primary">Mentés (DXF)</button>
      </div>

      <div class="note">
        A DXF-ben a hópehely befoglaló dobozának nagyobbik mérete ≈ 100 mm.
      </div>
    </div>

    <div class="canvas-container">
      <canvas id="snowflakeCanvas" width="600" height="600"></canvas>
    </div>
  </div>
</div>

<script>
  // --- Globális állapot ---
  let currentModel = null; // { rects: [poly...], minX, maxX, minY, maxY }
  const DXF_TARGET_SIZE = 100.0; // mm
  let showOutline = false;       // alapból kontúr kikapcsolva

  // --- Paraméterkezelés ---

  function syncInputPair(sliderId, numberId, onChange) {
    const slider = document.getElementById(sliderId);
    const input  = document.getElementById(numberId);

    slider.addEventListener('input', () => {
      input.value = slider.value;
      onChange();
    });

    input.addEventListener('change', () => {
      let v = parseFloat(input.value);
      const min = parseFloat(slider.min);
      const max = parseFloat(slider.max);
      if (isNaN(v)) v = min;
      v = Math.max(min, Math.min(max, v));
      input.value = v;
      slider.value = v;
      onChange();
    });
  }

  function getParams() {
    const angleVal     = parseFloat(document.getElementById('angleSlider').value);
    const ratioVal     = parseFloat(document.getElementById('ratioSlider').value);
    const spacingVal   = parseFloat(document.getElementById('spacingSlider').value);
    const redVal       = parseFloat(document.getElementById('reductionSlider').value);
    const armsVal      = parseInt(document.getElementById('armsSlider').value, 10);
    const minRectVal   = parseFloat(document.getElementById('minRectSlider').value);
    const growCheckbox = document.getElementById('growSmallCheckbox').checked;
    const tipStyleVal  = document.getElementById('tipStyleSelect').value;

    // 0=egyenes, 1=háromszög (sátor), 2=Y, 3=hatszög, 4=trapéz
    let tipMode = 0;
    if (tipStyleVal === 'tent') tipMode = 1;
    else if (tipStyleVal === 'Y') tipMode = 2;
    else if (tipStyleVal === 'hex') tipMode = 3;
    else if (tipStyleVal === 'trap') tipMode = 4;

    return {
      branchAngleDeg:    Number.isFinite(angleVal)   ? angleVal   : 30,
      rectAspectPercent: Number.isFinite(ratioVal)   ? ratioVal   : 20,
      spacingPercent:    Number.isFinite(spacingVal) ? spacingVal : 30,
      reductionPercent:  Number.isFinite(redVal)     ? redVal     : 40,
      armCount:          Number.isFinite(armsVal)    ? armsVal    : 6,
      minRectMm:         Number.isFinite(minRectVal) ? minRectVal : 0,
      growSmallRects:    growCheckbox,
      tipMode:           tipMode
    };
  }

  // --- Segéd: téglalap bázispontból ---

  function makeRectFromBase(bx, by, length, width, angleRad) {
    const d = { x: Math.cos(angleRad), y: Math.sin(angleRad) };        // hossz irány
    const n = { x: -Math.sin(angleRad), y: Math.cos(angleRad) };       // szélesség irány

    const halfL = length / 2;
    const halfW = width / 2;

    const cx = bx + d.x * halfL;
    const cy = by + d.y * halfL;

    const p1 = [ cx + n.x * halfW + d.x * halfL, cy + n.y * halfW + d.y * halfL ]; // távoli bal
    const p2 = [ cx - n.x * halfW + d.x * halfL, cy - n.y * halfW + d.y * halfL ]; // távoli jobb
    const p3 = [ cx - n.x * halfW - d.x * halfL, cy - n.y * halfW - d.y * halfL ]; // közeli jobb
    const p4 = [ cx + n.x * halfW - d.x * halfL, cy + n.y * halfW - d.y * halfL ]; // közeli bal

    return [p1, p2, p3, p4, p1.slice()]; // zárt gyűrű
  }

  // --- Egy fa (egy kar) szegmensei ---

  function buildSingleTreeSegments(params) {
    const segments = [];

    const trunkLength = 50;  // modell egység
    const aspect = Math.max(0.02, params.rectAspectPercent / 100.0);
    const trunkWidth = trunkLength * aspect;

    const trunkAngle = Math.PI / 2; // felfelé
    const spacing = params.spacingPercent;
    const angleOffset = params.branchAngleDeg * Math.PI / 180.0;
    const reduction = Math.max(0, Math.min(0.95, params.reductionPercent / 100.0));
    const tipMode = params.tipMode;

    // törzs
    segments.push({
      bx: 0, by: 0,
      length: trunkLength,
      width: trunkWidth,
      angle: trunkAngle,
      tipMode
    });

    const count = Math.floor(100 / spacing);
    if (count <= 0) return segments;

    const dTrunk = { x: Math.cos(trunkAngle), y: Math.sin(trunkAngle) };
    const signs = [+1, -1];

    for (let i = 1; i <= count; i++) {
      const t = i * spacing / 100.0;
      const posOnTrunk = trunkLength * t;

      const baseX = dTrunk.x * posOnTrunk;
      const baseY = dTrunk.y * posOnTrunk;

      let branchLength;
      if (reduction === 0) {
        branchLength = trunkLength;
      } else {
        branchLength = trunkLength * Math.pow(1 - reduction, i);
      }
      const branchWidth = branchLength * aspect;

      for (const sign of signs) {
        const branchAngle = trunkAngle + sign * angleOffset;
        segments.push({
          bx: baseX, by: baseY,
          length: branchLength,
          width: branchWidth,
          angle: branchAngle,
          tipMode
        });

        const dBranch = { x: Math.cos(branchAngle), y: Math.sin(branchAngle) };

        // ágacskák
        for (let j = 1; j <= count; j++) {
          const t2 = j * spacing / 100.0;
          const posOnBranch = branchLength * t2;

          const twigBaseX = baseX + dBranch.x * posOnBranch;
          const twigBaseY = baseY + dBranch.y * posOnBranch;

          let twigLength;
          if (reduction === 0) {
            twigLength = branchLength;
          } else {
            twigLength = branchLength * Math.pow(1 - reduction, j);
          }
          const twigWidth = twigLength * aspect;

          for (const sign2 of signs) {
            const twigAngle = branchAngle + sign2 * angleOffset;
            segments.push({
              bx: twigBaseX, by: twigBaseY,
              length: twigLength,
              width: twigWidth,
              angle: twigAngle,
              tipMode
            });
          }
        }
      }
    }

    return segments;
  }

  // Hópehely: fa szegmensek elforgatva
  function buildSnowflakeSegments(params) {
    const baseSegs = buildSingleTreeSegments(params);
    const arms = Math.max(3, params.armCount);
    const all = [];
    const twoPi = 2 * Math.PI;

    for (let k = 0; k < arms; k++) {
      const phi = twoPi * k / arms;
      const cosP = Math.cos(phi);
      const sinP = Math.sin(phi);

      for (const s of baseSegs) {
        const x = s.bx;
        const y = s.by;
        const rx = x * cosP - y * sinP;
        const ry = x * sinP + y * cosP;

        all.push({
          bx: rx,
          by: ry,
          length: s.length,
          width: s.width,
          angle: s.angle + phi,
          tipMode: s.tipMode
        });
      }
    }
    return all;
  }

  // Szegmens -> poligonok (téglalap + végforma)
  function segmentToPolys(seg) {
    const polys = [];
    const mainRect = makeRectFromBase(seg.bx, seg.by, seg.length, seg.width, seg.angle);
    polys.push(mainRect); // téglalap

    const tipMode = seg.tipMode;
    if (tipMode === 0) return polys;

    // szegmens iránya
    const d = { x: Math.cos(seg.angle), y: Math.sin(seg.angle) };
    const tipBaseX = seg.bx + d.x * seg.length;
    const tipBaseY = seg.by + d.y * seg.length;

    if (tipMode === 2) {
      // Y vég: két kis ág ±60°
      const capLength = seg.length * 0.3;
      const capWidth  = seg.width;
      const deltas = [Math.PI / 3, -Math.PI / 3];
      for (const delta of deltas) {
        const tipAngle = seg.angle + delta;
        polys.push(makeRectFromBase(tipBaseX, tipBaseY, capLength, capWidth, tipAngle));
      }
    } else if (tipMode === 1) {
      // Háromszög (korábbi sátor, 120°-os csúcs)
      const p1 = mainRect[0]; // távoli bal
      const p2 = mainRect[1]; // távoli jobb
      const dxB = p2[0] - p1[0];
      const dyB = p2[1] - p1[1];
      const b = Math.hypot(dxB, dyB);
      if (b > 1e-9) {
        const h = b / (2 * Math.sqrt(3));
        const midX = (p1[0] + p2[0]) * 0.5;
        const midY = (p1[1] + p2[1]) * 0.5;
        const apexX = midX + d.x * h;
        const apexY = midY + d.y * h;
        const tri = [
          [p1[0], p1[1]],
          [p2[0], p2[1]],
          [apexX, apexY],
          [p1[0], p1[1]]
        ];
        polys.push(tri);
      }
    } else if (tipMode === 3) {
      // Hatszög: szabályos, a távoli él az egyik oldala
      const p1 = mainRect[0];
      const p2 = mainRect[1];
      const dxB = p2[0] - p1[0];
      const dyB = p2[1] - p1[1];
      const b = Math.hypot(dxB, dyB);
      if (b > 1e-9) {
        const wdir = { x: dxB / b, y: dyB / b }; // p1->p2
        const midX = (p1[0] + p2[0]) * 0.5;
        const midY = (p1[1] + p2[1]) * 0.5;
        const sqrt3 = Math.sqrt(3);

        // Szabályos hatszög lokális koordinátái
        const local = [
          [-b/2, 0],
          [ b/2, 0],
          [ b,   (sqrt3/2)*b ],
          [ b/2, sqrt3*b ],
          [-b/2, sqrt3*b ],
          [-b,   (sqrt3/2)*b ]
        ];

        function toWorld(X, Y) {
          return [
            midX + X * wdir.x + Y * d.x,
            midY + X * wdir.y + Y * d.y
          ];
        }

        const hexPoly = local.map(([X,Y]) => toWorld(X,Y));
        hexPoly.push(hexPoly[0].slice());
        polys.push(hexPoly);
      }
    } else if (tipMode === 4) {
      // Trapéz: hosszú alap = b, rövid alap = b/2, oldalak = b/2 (fél szabályos hatszög)
      const p1 = mainRect[0]; // távoli bal
      const p2 = mainRect[1]; // távoli jobb
      const dxB = p2[0] - p1[0];
      const dyB = p2[1] - p1[1];
      const b = Math.hypot(dxB, dyB);
      if (b > 1e-9) {
        const wdir = { x: dxB / b, y: dyB / b }; // p1->p2
        const midX = (p1[0] + p2[0]) * 0.5;
        const midY = (p1[1] + p2[1]) * 0.5;
        const sqrt3 = Math.sqrt(3);

        // h = (√3/4)*b, felső alap hossza = b/2, középen
        const h = (sqrt3 / 4) * b;
        const halfTop = b / 4;

        // Lokális pontok: (-b/2,0), (b/2,0), (b/4,h), (-b/4,h)
        const local = [
          [-b/2, 0],
          [ b/2, 0],
          [ halfTop, h],
          [-halfTop, h]
        ];

        function toWorld(X, Y) {
          return [
            midX + X * wdir.x + Y * d.x,
            midY + X * wdir.y + Y * d.y
          ];
        }

        const trapPoly = local.map(([X,Y]) => toWorld(X,Y));
        trapPoly.push(trapPoly[0].slice());
        polys.push(trapPoly);
      }
    }

    return polys;
  }

  // --- Geometria frissítése: szegmensek + min. vastagság ---

  function updateGeometry() {
    const params = getParams();
    const segments = buildSnowflakeSegments(params);

    if (!segments.length) {
      currentModel = { rects: [], minX: 0, maxX: 0, minY: 0, maxY: 0 };
      return;
    }

    // 1) Első közelítő bbox
    let minX0 = Infinity, maxX0 = -Infinity;
    let minY0 = Infinity, maxY0 = -Infinity;

    for (const seg of segments) {
      const polys = segmentToPolys(seg);
      for (const poly of polys) {
        for (const [x,y] of poly) {
          if (x < minX0) minX0 = x;
          if (x > maxX0) maxX0 = x;
          if (y < minY0) minY0 = y;
          if (y > maxY0) maxY0 = y;
        }
      }
    }

    const width0 = maxX0 - minX0 || 1;
    const height0 = maxY0 - minY0 || 1;
    const size0 = Math.max(width0, height0) || 1;

    const scaleModelToMm = DXF_TARGET_SIZE / size0;
    const minRectMm = Math.max(0, params.minRectMm || 0);
    const growSmall = params.growSmallRects;
    const minWidthModel = minRectMm > 0 ? (minRectMm / scaleModelToMm) : 0;

    // 2) Szegmensek szélesség-korrekció
    const adjustedSegments = [];
    for (const seg of segments) {
      if (minWidthModel <= 0) {
        adjustedSegments.push(seg);
      } else {
        if (seg.width >= minWidthModel) {
          adjustedSegments.push(seg);
        } else {
          if (!growSmall) {
            continue;
          } else {
            adjustedSegments.push({
              ...seg,
              width: minWidthModel
            });
          }
        }
      }
    }

    if (!adjustedSegments.length) {
      currentModel = { rects: [], minX: 0, maxX: 0, minY: 0, maxY: 0 };
      return;
    }

    // 3) Poligonok + végső bbox
    const rects = [];
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;

    for (const seg of adjustedSegments) {
      const polys = segmentToPolys(seg);
      for (const poly of polys) {
        rects.push(poly);
        for (const [x,y] of poly) {
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
          if (y < minY) minY = y;
          if (y > maxY) maxY = y;
        }
      }
    }

    currentModel = { rects, minX, maxX, minY, maxY };
  }

  // --- Rajzolás vászonra ---

  function redraw() {
    if (!currentModel) return;

    const canvas = document.getElementById('snowflakeCanvas');
    const ctx = canvas.getContext('2d');

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const { rects, minX, maxX, minY, maxY } = currentModel;
    if (!rects.length) return;

    const width = maxX - minX || 1;
    const height = maxY - minY || 1;
    const scale = 0.9 * Math.min(canvas.width / width, canvas.height / height);
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY) / 2;

    const fillColor = '#bfe9ff';
    const strokeColor = showOutline ? '#000000' : fillColor;

    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.strokeStyle = strokeColor;
    ctx.fillStyle = fillColor;
    ctx.lineWidth = 1.2;

    for (const poly of rects) {
      if (poly.length < 2) continue;
      ctx.beginPath();
      for (let i = 0; i < poly.length; i++) {
        const x = poly[i][0];
        const y = poly[i][1];

        const sx = canvas.width / 2 + (x - cx) * scale;
        const sy = canvas.height / 2 - (y - cy) * scale;

        if (i === 0) ctx.moveTo(sx, sy);
        else ctx.lineTo(sx, sy);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }
  }

  function recomputeAndRedraw() {
    updateGeometry();
    redraw();
  }

  // --- Skálázás DXF-hez ---

  function getScaledPolys() {
    if (!currentModel) return null;
    const { rects, minX, maxX, minY, maxY } = currentModel;
    if (!rects.length) return null;

    const width = maxX - minX || 1;
    const height = maxY - minY || 1;
    const size = Math.max(width, height) || 1;
    const scale = DXF_TARGET_SIZE / size;

    const scaled = rects.map(poly =>
      poly.map(([x,y]) => [ (x - minX) * scale, (y - minY) * scale ])
    );

    return { scaledPolys: scaled };
  }

  function downloadDXF(dxfString, filename) {
    if (!dxfString) return;
    const blob = new Blob([dxfString], { type: 'application/dxf' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename.endsWith('.dxf') ? filename : (filename + '.dxf');
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // --- DXF: poligonok háromszögekre bontva SOLID-ként ---

  function exportDXFRectanglesSolid() {
    const scaled = getScaledPolys();
    if (!scaled) {
      alert('Nincs exportálható elem (a min. vastagság szűrés esetleg mindent eltüntetett).');
      return;
    }
    const { scaledPolys } = scaled;

    let dxf = '';
    const NL = '\r\n';
    function add(code, value) {
      dxf += code + NL + value + NL;
    }

    add(0, 'SECTION');
    add(2, 'HEADER');
    add(0, 'ENDSEC');

    add(0, 'SECTION');
    add(2, 'ENTITIES');

    for (const poly of scaledPolys) {
      if (poly.length < 4) continue; // legalább 3 egyedi pont + zárás

      const unique = poly.slice(0, poly.length - 1);
      const n = unique.length;
      if (n < 3) continue;

      const v0 = unique[0];

      // Háromszög-fan: (v0, v_i, v_{i+1})
      for (let i = 1; i < n - 1; i++) {
        const v1 = unique[i];
        const v2 = unique[i+1];

        add(0, 'SOLID');
        add(8, '0');

        add(10, v0[0].toFixed(4));
        add(20, v0[1].toFixed(4));
        add(30, '0.0');

        add(11, v1[0].toFixed(4));
        add(21, v1[1].toFixed(4));
        add(31, '0.0');

        add(12, v2[0].toFixed(4));
        add(22, v2[1].toFixed(4));
        add(32, '0.0');

        // háromszög: 3. és 4. pont azonos
        add(13, v2[0].toFixed(4));
        add(23, v2[1].toFixed(4));
        add(33, '0.0');
      }
    }

    add(0, 'ENDSEC');
    add(0, 'EOF');

    const p = getParams();
    const aa = Math.round(p.branchAngleDeg);
    const bb = Math.round(p.rectAspectPercent);
    const cc = Math.round(p.spacingPercent);
    const dd = Math.round(p.reductionPercent);
    const ee = p.armCount;
    const ff = p.minRectMm.toFixed(1);
    const flag = p.growSmallRects ? 'Y' : 'N';

    const filename = `PEHELY-${aa}-${bb}-${cc}-${dd}-${ee}-${ff}-${flag}.dxf`;
    downloadDXF(dxf, filename);
  }

  // --- Véletlen paraméterek ---

  function randomizeParams() {
    function randInt(min, max) {
      return Math.round(min + Math.random() * (max - min));
    }

    const angle = randInt(15, 120);
    document.getElementById('angleSlider').value = angle;
    document.getElementById('angleInput').value  = angle;

    const ratio = randInt(8, 30);
    document.getElementById('ratioSlider').value = ratio;
    document.getElementById('ratioInput').value  = ratio;

    const spacing = randInt(15, 45);
    document.getElementById('spacingSlider').value = spacing;
    document.getElementById('spacingInput').value  = spacing;

    const reduction = randInt(20, 60);
    document.getElementById('reductionSlider').value = reduction;
    document.getElementById('reductionInput').value  = reduction;

    // Karok száma, Min. vastagság, Kisebbek növelése, végforma NEM változik
    recomputeAndRedraw();
  }

  // --- Kontúr ki/be ---

  function toggleOutline() {
    showOutline = !showOutline;
    redraw();
  }

  // --- Init ---

  window.addEventListener('load', () => {
    syncInputPair('angleSlider',    'angleInput',    recomputeAndRedraw);
    syncInputPair('ratioSlider',    'ratioInput',    recomputeAndRedraw);
    syncInputPair('spacingSlider',  'spacingInput',  recomputeAndRedraw);
    syncInputPair('reductionSlider','reductionInput',recomputeAndRedraw);
    syncInputPair('armsSlider',     'armsInput',     recomputeAndRedraw);
    syncInputPair('minRectSlider',  'minRectInput',  recomputeAndRedraw);

    document.getElementById('growSmallCheckbox')
      .addEventListener('change', recomputeAndRedraw);
    document.getElementById('tipStyleSelect')
      .addEventListener('change', recomputeAndRedraw);

    document.getElementById('randomBtn')
      .addEventListener('click', randomizeParams);
    document.getElementById('toggleOutlineBtn')
      .addEventListener('click', toggleOutline);
    document.getElementById('exportSolidBtn')
      .addEventListener('click', exportDXFRectanglesSolid);

    recomputeAndRedraw();
  });
</script>
</body>
</html>
