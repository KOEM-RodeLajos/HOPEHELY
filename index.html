<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rodé Lajos - Hópehely generátor</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body {
      margin: 0;
      padding: 0;
      background: #f2f4f8;
      color: #222;
    }
    h1 {
      font-size: 1.4rem;
      margin: 0 0 0.5rem 0;
    }
    h2 {
      font-size: 1rem;
      margin-top: 0;
    }
    .page {
      max-width: 1100px;
      margin: 0 auto;
      padding: 1rem;
    }
    .container {
      display: flex;
      gap: 1rem;
      align-items: stretch;
    }
    .controls {
      flex: 0 0 360px;
      max-width: 100%;
      background: #fff;
      border-radius: 8px;
      padding: 0.8rem 1rem 1rem;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    }
    .controls-inner {
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
    }
    .canvas-container {
      flex: 1;
      background: #001633;
      border-radius: 8px;
      padding: 0.5rem;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 0;
    }
    .control-group {
      margin-bottom: 0.2rem;
    }
    .control-group label {
      display: block;
      font-size: 0.85rem;
      margin-bottom: 0.2rem;
    }
    .control-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .control-row input[type="range"] {
      flex: 1;
    }
    .control-row input[type="number"] {
      width: 4.5rem;
      padding: 0.1rem 0.2rem;
    }
    .control-row .chk-label {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      font-size: 0.85rem;
      white-space: nowrap;
    }
    select {
      width: 100%;
      padding: 0.15rem 0.2rem;
      font-size: 0.85rem;
    }
    hr.separator {
      border: 0;
      border-top: 1px solid #ddd;
      margin: 0.4rem 0;
    }
    .buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    button {
      flex: 1 1 48%;
      padding: 0.35rem 0.6rem;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      transition: background 0.15s, box-shadow 0.15s, transform 0.05s;
    }
    button.primary {
      background: #0d6efd;
      color: #fff;
    }
    button.secondary {
      background: #e9ecef;
      color: #222;
    }
    button:hover {
      box-shadow: 0 1px 4px rgba(0,0,0,0.18);
    }
    button:active {
      transform: translateY(1px);
      box-shadow: 0 0 0 rgba(0,0,0,0);
    }
    canvas {
      border-radius: 8px;
      background: #001633;
      box-shadow: inset 0 0 6px rgba(0,0,0,0.4);
      max-width: 100%;
      height: auto;
      display: block;
    }

    /* Mobil / keskeny nézet: rajz a beállítások alatt */
    @media (max-width: 900px) {
      .container {
        flex-direction: column;
      }
      .controls {
        flex: none;
        width: 100%;
      }
    }
  </style>
</head>
<body>
<div class="page">
  <h1>Rodé Lajos - Hópehely generátor v20</h1>

  <div class="container">
    <div class="controls">
      <h2>Paraméterek</h2>

      <div class="controls-inner">
        <!-- Alap paraméterek -->
        <div class="control-group">
          <label for="angleSlider">Szög (°)</label>
          <div class="control-row">
            <input id="angleSlider" type="range" min="10" max="120" step="1" value="60">
            <input id="angleInput" type="number" min="10" max="120" step="1" value="60">
          </div>
        </div>

        <div class="control-group">
          <label for="ratioSlider">Vastagság (%)</label>
          <div class="control-row">
            <input id="ratioSlider" type="range" min="5" max="40" step="1" value="15">
            <input id="ratioInput" type="number" min="5" max="40" step="1" value="15">
          </div>
        </div>

        <div class="control-group">
          <label for="spacingSlider">Köz (%)</label>
          <div class="control-row">
            <input id="spacingSlider" type="range" min="10" max="50" step="1" value="50">
            <input id="spacingInput" type="number" min="10" max="50" step="1" value="50">
          </div>
        </div>

        <div class="control-group">
          <label for="reductionSlider">Méretcsökkenés (%)</label>
          <div class="control-row">
            <input id="reductionSlider" type="range" min="0" max="70" step="1" value="50">
            <input id="reductionInput" type="number" min="0" max="70" step="1" value="50">
          </div>
        </div>

        <hr class="separator">

        <!-- Végforma blokk -->
        <div class="control-group">
          <label for="tipStyleSelect">Végforma</label>
          <select id="tipStyleSelect">
            <option value="straight" selected>Egyenes</option>
            <option value="tent">Háromszög</option>
            <option value="trap">Trapéz</option>
            <option value="hex">Hatszög</option>
            <option value="Y">Y</option>
          </select>
        </div>

        <div class="control-group">
          <label for="tipScaleSlider">Végforma méret</label>
          <div class="control-row">
            <input id="tipScaleSlider" type="range" min="0.2" max="5" step="0.05" value="1">
            <input id="tipScaleInput" type="number" min="0.2" max="5" step="0.05" value="1">
          </div>
        </div>

        <div class="control-group">
          <div class="control-row">
            <label class="chk-label">
              <input type="checkbox" id="tipOnlyCheckbox">
              Csak végforma
            </label>
            <label class="chk-label">
              <input type="checkbox" id="tipCenterCheckbox" checked>
              Közép
            </label>
            <label class="chk-label">
              <input type="checkbox" id="showTrunkCheckbox" checked>
              Törzs
            </label>
          </div>
        </div>

        <hr class="separator">

        <div class="control-group">
          <label for="armsSlider">Karok száma</label>
          <div class="control-row">
            <input id="armsSlider" type="range" min="3" max="12" step="1" value="6">
            <input id="armsInput" type="number" min="3" max="12" step="1" value="6">
          </div>
        </div>

        <hr class="separator">

        <div class="control-group">
          <label for="minRectSlider">Min. vastagság (mm)</label>
          <div class="control-row">
            <input id="minRectSlider" type="range" min="0" max="10" step="0.1" value="3.0">
            <input id="minRectInput" type="number" min="0" max="10" step="0.1" value="3.0">
          </div>
        </div>

        <div class="control-group">
          <label>
            <input type="checkbox" id="growSmallCheckbox" checked>
            Kisebbek növelése
          </label>
        </div>

        <div class="buttons">
          <button id="randomBtn" class="secondary">Véletlen paraméterek</button>
          <button id="toggleOutlineBtn" class="secondary">Kontúr ki/be</button>
          <button id="exportSolidBtn" class="primary">MENTÉS</button>
        </div>
      </div>
    </div>

    <div class="canvas-container">
      <canvas id="snowflakeCanvas" width="600" height="600"></canvas>
    </div>
  </div>
</div>

<script>
  // --- Globális állapot ---
  let currentModel = null; // { rects: [poly...], minX, maxX, minY, maxY }
  const DXF_TARGET_SIZE = 100.0; // mm
  let showOutline = false;       // alapból kontúr kikapcsolva

  // --- Paraméterkezelés ---

  function syncInputPair(sliderId, numberId, onChange) {
    const slider = document.getElementById(sliderId);
    const input  = document.getElementById(numberId);

    slider.addEventListener('input', () => {
      input.value = slider.value;
      onChange();
    });

    input.addEventListener('change', () => {
      let v = parseFloat(input.value);
      const min = parseFloat(slider.min);
      const max = parseFloat(slider.max);
      if (isNaN(v)) v = min;
      v = Math.max(min, Math.min(max, v));
      input.value = v;
      slider.value = v;
      onChange();
    });
  }

  function getParams() {
    const angleVal     = parseFloat(document.getElementById('angleSlider').value);
    const ratioVal     = parseFloat(document.getElementById('ratioSlider').value);
    const spacingVal   = parseFloat(document.getElementById('spacingSlider').value);
    const redVal       = parseFloat(document.getElementById('reductionSlider').value);
    const armsVal      = parseInt(document.getElementById('armsSlider').value, 10);
    const minRectVal   = parseFloat(document.getElementById('minRectSlider').value);
    const growCheckbox = document.getElementById('growSmallCheckbox').checked;
    const tipStyleVal  = document.getElementById('tipStyleSelect').value;
    const tipScaleVal  = parseFloat(document.getElementById('tipScaleSlider').value);
    const tipOnlyVal   = document.getElementById('tipOnlyCheckbox').checked;
    const tipCenterVal = document.getElementById('tipCenterCheckbox').checked;
    const showTrunkVal = document.getElementById('showTrunkCheckbox').checked;

    // 0=egyenes, 1=háromszög, 2=Y, 3=hatszög, 4=trapéz
    let tipMode = 0;
    if (tipStyleVal === 'tent') tipMode = 1;
    else if (tipStyleVal === 'Y') tipMode = 2;
    else if (tipStyleVal === 'hex') tipMode = 3;
    else if (tipStyleVal === 'trap') tipMode = 4;

    return {
      branchAngleDeg:    Number.isFinite(angleVal)   ? angleVal   : 30,
      rectAspectPercent: Number.isFinite(ratioVal)   ? ratioVal   : 20,
      spacingPercent:    Number.isFinite(spacingVal) ? spacingVal : 30,
      reductionPercent:  Number.isFinite(redVal)     ? redVal     : 40,
      tipMode:           tipMode,
      tipScale:          Number.isFinite(tipScaleVal) ? tipScaleVal : 1,
      tipOnly:           tipOnlyVal,
      tipAtCenter:       tipCenterVal,
      showTrunk:         showTrunkVal,
      armCount:          Number.isFinite(armsVal)    ? armsVal    : 6,
      minRectMm:         Number.isFinite(minRectVal) ? minRectVal : 0,
      growSmallRects:    growCheckbox
    };
  }

  // --- Segéd: téglalap bázispontból ---

  function makeRectFromBase(bx, by, length, width, angleRad) {
    const d = { x: Math.cos(angleRad), y: Math.sin(angleRad) };        // hossz irány
    const n = { x: -Math.sin(angleRad), y: Math.cos(angleRad) };       // szélesség irány

    const halfL = length / 2;
    const halfW = width / 2;

    const cx = bx + d.x * halfL;
    const cy = by + d.y * halfL;

    const p1 = [ cx + n.x * halfW + d.x * halfL, cy + n.y * halfW + d.y * halfL ]; // távoli bal
    const p2 = [ cx - n.x * halfW + d.x * halfL, cy - n.y * halfW + d.y * halfL ]; // távoli jobb
    const p3 = [ cx - n.x * halfW - d.x * halfL, cy - n.y * halfW - d.y * halfL ]; // közeli jobb
    const p4 = [ cx + n.x * halfW - d.x * halfL, cy + n.y * halfW - d.y * halfL ]; // közeli bal

    return [p1, p2, p3, p4, p1.slice()]; // zárt gyűrű
  }

  // --- Segéd: poligon skálázása a saját középpontjából ---

  function scalePolygon(poly, scale) {
    if (!poly || poly.length < 2 || scale === 1) return poly;
    const unique = poly.slice(0, poly.length - 1);
    if (!unique.length) return poly;

    let cx = 0, cy = 0;
    for (const [x, y] of unique) {
      cx += x; cy += y;
    }
    cx /= unique.length;
    cy /= unique.length;

    const scaled = unique.map(([x, y]) => [
      cx + (x - cx) * scale,
      cy + (y - cy) * scale
    ]);
    scaled.push(scaled[0].slice());
    return scaled;
  }

  // --- Egy fa (egy kar) szegmensei ---

  function buildSingleTreeSegments(params) {
    const segments = [];

    const trunkLength = 50;  // modell egység
    const aspect = Math.max(0.02, params.rectAspectPercent / 100.0);
    const trunkWidth = trunkLength * aspect;

    const trunkAngle = Math.PI / 2; // felfelé
    const spacing = params.spacingPercent;
    const angleOffset = params.branchAngleDeg * Math.PI / 180.0;
    const reduction = Math.max(0, Math.min(0.95, params.reductionPercent / 100.0));
    const tipMode = params.tipMode;
    const tipScale = Number.isFinite(params.tipScale) ? params.tipScale : 1;

    // törzs
    segments.push({
      bx: 0, by: 0,
      length: trunkLength,
      width: trunkWidth,
      angle: trunkAngle,
      tipMode,
      tipScale,
      isTrunk: true
    });

    const count = Math.floor(100 / spacing);
    if (count <= 0) return segments;

    const dTrunk = { x: Math.cos(trunkAngle), y: Math.sin(trunkAngle) };
    const signs = [+1, -1];

    for (let i = 1; i <= count; i++) {
      const t = i * spacing / 100.0;
      const posOnTrunk = trunkLength * t;

      const baseX = dTrunk.x * posOnTrunk;
      const baseY = dTrunk.y * posOnTrunk;

      let branchLength;
      if (reduction === 0) {
        branchLength = trunkLength;
      } else {
        branchLength = trunkLength * Math.pow(1 - reduction, i);
      }
      const branchWidth = branchLength * aspect;

      for (const sign of signs) {
        const branchAngle = trunkAngle + sign * angleOffset;
        segments.push({
          bx: baseX, by: baseY,
          length: branchLength,
          width: branchWidth,
          angle: branchAngle,
          tipMode,
          tipScale,
          isTrunk: false
        });

        const dBranch = { x: Math.cos(branchAngle), y: Math.sin(branchAngle) };

        // ágacskák
        for (let j = 1; j <= count; j++) {
          const t2 = j * spacing / 100.0;
          const posOnBranch = branchLength * t2;

          const twigBaseX = baseX + dBranch.x * posOnBranch;
          const twigBaseY = baseY + dBranch.y * posOnBranch;

          let twigLength;
          if (reduction === 0) {
            twigLength = branchLength;
          } else {
            twigLength = branchLength * Math.pow(1 - reduction, j);
          }
          const twigWidth = twigLength * aspect;

          for (const sign2 of signs) {
            const twigAngle = branchAngle + sign2 * angleOffset;
            segments.push({
              bx: twigBaseX, by: twigBaseY,
              length: twigLength,
              width: twigWidth,
              angle: twigAngle,
              tipMode,
              tipScale,
              isTrunk: false
            });
          }
        }
      }
    }

    return segments;
  }

  // Hópehely: fa szegmensek elforgatva
  function buildSnowflakeSegments(params) {
    const baseSegs = buildSingleTreeSegments(params);
    const arms = Math.max(3, params.armCount);
    const all = [];
    const twoPi = 2 * Math.PI;

    for (let k = 0; k < arms; k++) {
      const phi = twoPi * k / arms;
      const cosP = Math.cos(phi);
      const sinP = Math.sin(phi);

      for (const s of baseSegs) {
        const x = s.bx;
        const y = s.by;
        const rx = x * cosP - y * sinP;
        const ry = x * sinP + y * cosP;

        all.push({
          bx: rx,
          by: ry,
          length: s.length,
          width: s.width,
          angle: s.angle + phi,
          tipMode: s.tipMode,
          tipScale: s.tipScale,
          isTrunk: s.isTrunk
        });
      }
    }
    return all;
  }

  // --- Segéd: tip-poligonok ---

  function buildTentHexFromEdge(p1, p2, dir, tipScale) {
    const dxB = p2[0] - p1[0];
    const dyB = p2[1] - p1[1];
    const b = Math.hypot(dxB, dyB);
    if (b <= 1e-9) return null;

    const baseDir = { x: dxB / b, y: dyB / b };
    const sqrt3 = Math.sqrt(3);
    const h = b / (2 * sqrt3);
    const midX = (p1[0] + p2[0]) * 0.5;
    const midY = (p1[1] + p2[1]) * 0.5;
    const apexX = midX + dir.x * h;
    const apexY = midY + dir.y * h;

    const A = p1;
    const B = p2;
    const C = [apexX, apexY];

    const v = { x: C[0] - A[0], y: C[1] - A[1] };
    const dot = v.x * baseDir.x + v.y * baseDir.y;
    const v_par = { x: baseDir.x * dot, y: baseDir.y * dot };
    const v_perp = { x: v.x - v_par.x, y: v.y - v_par.y };
    const C_ref = [ C[0] - 2 * v_perp.x, C[1] - 2 * v_perp.y ];

    const sLen = Math.hypot(C[0] - A[0], C[1] - A[1]);
    const t = { x: -dir.x * sLen, y: -dir.y * sLen };

    const A2 = [ A[0] + t.x, A[1] + t.y ];
    const B2 = [ B[0] + t.x, B[1] + t.y ];
    const C2 = [ C_ref[0] + t.x, C_ref[1] + t.y ];

    const pts = [A, B, C, A2, B2, C2].map(p => [p[0], p[1]]);

    let cx = 0, cy = 0;
    for (const [x, y] of pts) {
      cx += x; cy += y;
    }
    cx /= pts.length;
    cy /= pts.length;

    pts.sort((p, q) => {
      const angP = Math.atan2(p[1] - cy, p[0] - cx);
      const angQ = Math.atan2(q[1] - cy, q[0] - cx);
      return angP - angQ;
    });

    const hexPoly = pts.slice();
    hexPoly.push(hexPoly[0].slice());
    return scalePolygon(hexPoly, tipScale);
  }

  function buildRegularHexFromEdge(p1, p2, dir, tipScale) {
    const dxB = p2[0] - p1[0];
    const dyB = p2[1] - p1[1];
    const b = Math.hypot(dxB, dyB);
    if (b <= 1e-9) return null;

    const wdir = { x: dxB / b, y: dyB / b };
    const midX = (p1[0] + p2[0]) * 0.5;
    const midY = (p1[1] + p2[1]) * 0.5;
    const sqrt3 = Math.sqrt(3);

    const local = [
      [-b/2, 0],
      [ b/2, 0],
      [ b,   (sqrt3/2)*b ],
      [ b/2,  sqrt3*b    ],
      [-b/2,  sqrt3*b    ],
      [-b,   (sqrt3/2)*b ]
    ];

    function toWorld(X, Y) {
      return [
        midX + X * wdir.x + Y * dir.x,
        midY + X * wdir.y + Y * dir.y
      ];
    }

    const hexPoly = local.map(([X,Y]) => toWorld(X,Y));
    hexPoly.push(hexPoly[0].slice());
    return scalePolygon(hexPoly, tipScale);
  }

  function buildTrapHexFromEdge(p1, p2, dir, tipScale) {
    const dxB = p2[0] - p1[0];
    const dyB = p2[1] - p1[1];
    const b = Math.hypot(dxB, dyB);
    if (b <= 1e-9) return null;

    const wdir = { x: dxB / b, y: dyB / b };
    const midX = (p1[0] + p2[0]) * 0.5;
    const midY = (p1[1] + p2[1]) * 0.5;
    const sqrt3 = Math.sqrt(3);

    const h = (sqrt3 / 4) * b;
    const halfTop = b / 4;

    const local = [
      [ b/2,     0   ], // BR
      [ halfTop, h   ], // OR
      [-halfTop, h   ], // OL
      [-b/2,     0   ], // BL
      [-halfTop,-h   ], // IL
      [ halfTop,-h   ]  // IR
    ];

    function toWorld(X, Y) {
      return [
        midX + X * wdir.x + Y * dir.x,
        midY + X * wdir.y + Y * dir.y
      ];
    }

    const hexTrapPoly = local.map(([X,Y]) => toWorld(X,Y));
    hexTrapPoly.push(hexTrapPoly[0].slice());
    return scalePolygon(hexTrapPoly, tipScale);
  }

  // Szegmens -> poligonok (téglalap + végforma)
  function segmentToPolys(seg, params) {
    const polys = [];
    const mainRect = makeRectFromBase(seg.bx, seg.by, seg.length, seg.width, seg.angle);

    const tipMode     = seg.tipMode;
    const tipScale    = (typeof seg.tipScale === 'number' && isFinite(seg.tipScale)) ? seg.tipScale : 1;
    const onlyTips    = !!params.tipOnly;
    const addBaseTips = !!params.tipAtCenter && !!seg.isTrunk;
    const showTrunk   = !!params.showTrunk;

    // Törzs mindig rajzolódik, ha showTrunk=true, függetlenül a "Csak végforma"-tól.
    if (seg.isTrunk) {
      if (showTrunk) {
        polys.push(mainRect);
      }
    } else {
      // Ágak/ágacskák esetén a "Csak végforma" szűr.
      if (!onlyTips) {
        polys.push(mainRect);
      }
    }

    if (tipMode === 0) return polys;

    const d = { x: Math.cos(seg.angle), y: Math.sin(seg.angle) };

    // Y végforma
    if (tipMode === 2) {
      function addYAt(baseX, baseY, mainAngle) {
        const capLength = seg.length * 0.3 * tipScale;
        const capWidth  = seg.width;
        const deltas = [Math.PI / 3, -Math.PI / 3];
        for (const delta of deltas) {
          const tipAngle = mainAngle + delta;
          polys.push(makeRectFromBase(baseX, baseY, capLength, capWidth, tipAngle));
        }
      }

      const tipBaseX = seg.bx + d.x * seg.length;
      const tipBaseY = seg.by + d.y * seg.length;
      addYAt(tipBaseX, tipBaseY, seg.angle);

      if (addBaseTips) {
        addYAt(seg.bx, seg.by, seg.angle + Math.PI);
      }

      return polys;
    }

    // poligonvégformák
    const p1_far = mainRect[0];
    const p2_far = mainRect[1];
    const p1_near = mainRect[3];
    const p2_near = mainRect[2];

    const dTop  = d;
    const dBase = { x: -d.x, y: -d.y };

    if (tipMode === 1) {
      const hexTop = buildTentHexFromEdge(p1_far,  p2_far,  dTop,  tipScale);
      if (hexTop) polys.push(hexTop);
      if (addBaseTips) {
        const hexBase = buildTentHexFromEdge(p1_near, p2_near, dBase, tipScale);
        if (hexBase) polys.push(hexBase);
      }
    } else if (tipMode === 3) {
      const hexTop = buildRegularHexFromEdge(p1_far,  p2_far,  dTop,  tipScale);
      if (hexTop) polys.push(hexTop);
      if (addBaseTips) {
        const hexBase = buildRegularHexFromEdge(p1_near, p2_near, dBase, tipScale);
        if (hexBase) polys.push(hexBase);
      }
    } else if (tipMode === 4) {
      const hexTop = buildTrapHexFromEdge(p1_far,  p2_far,  dTop,  tipScale);
      if (hexTop) polys.push(hexTop);
      if (addBaseTips) {
        const hexBase = buildTrapHexFromEdge(p1_near, p2_near, dBase, tipScale);
        if (hexBase) polys.push(hexBase);
      }
    }

    return polys;
  }

  // --- Poligon teszt: pont a poligonban? (ray casting) ---

  function pointInPolygon(x, y, poly) {
    let inside = false;
    const n = poly.length;
    for (let i = 0, j = n - 1; i < n; j = i++) {
      const xi = poly[i][0], yi = poly[i][1];
      const xj = poly[j][0], yj = poly[j][1];

      const intersect = ((yi > y) !== (yj > y)) &&
                        (x < (xj - xi) * (y - yi) / (yj - yi + 1e-12) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  // --- Geometria frissítése ---

  function updateGeometry() {
    const params = getParams();
    const segments = buildSnowflakeSegments(params);

    if (!segments.length) {
      currentModel = { rects: [], minX: 0, maxX: 0, minY: 0, maxY: 0 };
      return;
    }

    let minX0 = Infinity, maxX0 = -Infinity;
    let minY0 = Infinity, maxY0 = -Infinity;

    for (const seg of segments) {
      const polys = segmentToPolys(seg, params);
      for (const poly of polys) {
        for (const [x,y] of poly) {
          if (x < minX0) minX0 = x;
          if (x > maxX0) maxX0 = x;
          if (y < minY0) minY0 = y;
          if (y > maxY0) maxY0 = y;
        }
      }
    }

    const width0 = maxX0 - minX0 || 1;
    const height0 = maxY0 - minY0 || 1;
    const size0 = Math.max(width0, height0) || 1;

    const scaleModelToMm = DXF_TARGET_SIZE / size0;
    const minRectMm = Math.max(0, params.minRectMm || 0);
    const growSmall = params.growSmallRects;
    const minWidthModel = minRectMm > 0 ? (minRectMm / scaleModelToMm) : 0;

    const adjustedSegments = [];
    for (const seg of segments) {
      if (minWidthModel <= 0) {
        adjustedSegments.push(seg);
      } else {
        if (seg.width >= minWidthModel) {
          adjustedSegments.push(seg);
        } else {
          if (!growSmall) {
            continue;
          } else {
            adjustedSegments.push({
              ...seg,
              width: minWidthModel
            });
          }
        }
      }
    }

    if (!adjustedSegments.length) {
      currentModel = { rects: [], minX: 0, maxX: 0, minY: 0, maxY: 0 };
      return;
    }

    const rects = [];
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;

    for (const seg of adjustedSegments) {
      const polys = segmentToPolys(seg, params);
      for (const poly of polys) {
        rects.push(poly);
        for (const [x,y] of poly) {
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
          if (y < minY) minY = y;
          if (y > maxY) maxY = y;
        }
      }
    }

    currentModel = { rects, minX, maxX, minY, maxY };
  }

  // --- Rajzolás vászonra ---

  function redraw() {
    if (!currentModel) return;

    const canvas = document.getElementById('snowflakeCanvas');
    const ctx = canvas.getContext('2d');

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const { rects, minX, maxX, minY, maxY } = currentModel;
    if (!rects.length) return;

    const width = maxX - minX || 1;
    const height = maxY - minY || 1;
    const scale = 0.9 * Math.min(canvas.width / width, canvas.height / height);
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY) / 2;

    const fillColor = '#bfe9ff';
    const strokeColor = showOutline ? '#000000' : fillColor;

    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.strokeStyle = strokeColor;
    ctx.fillStyle = fillColor;
    ctx.lineWidth = 1.2;

    for (const poly of rects) {
      if (poly.length < 2) continue;
      ctx.beginPath();
      for (let i = 0; i < poly.length; i++) {
        const x = poly[i][0];
        const y = poly[i][1];

        const sx = canvas.width / 2 + (x - cx) * scale;
        const sy = canvas.height / 2 - (y - cy) * scale;

        if (i === 0) ctx.moveTo(sx, sy);
        else ctx.lineTo(sx, sy);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }
  }

  function recomputeAndRedraw() {
    updateGeometry();
    redraw();
  }

  // --- Skálázás DXF-hez ---

  function getScaledPolys() {
    if (!currentModel) return null;
    const { rects, minX, maxX, minY, maxY } = currentModel;
    if (!rects.length) return null;

    const width = maxX - minX || 1;
    const height = maxY - minY || 1;
    const size = Math.max(width, height) || 1;
    const scale = DXF_TARGET_SIZE / size;

    const scaled = rects.map(poly =>
      poly.map(([x,y]) => [ (x - minX) * scale, (y - minY) * scale ])
    );

    return { scaledPolys: scaled };
  }

  function downloadDXF(dxfString, filename) {
    if (!dxfString) return;
    const blob = new Blob([dxfString], { type: 'application/dxf' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename.endsWith('.dxf') ? filename : (filename + '.dxf');
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // --- Kódrész (PEHELY- utáni) összeállítása ---

  function buildCodeString() {
    const p = getParams();
    const angle  = Math.round(p.branchAngleDeg);
    const ratio  = Math.round(p.rectAspectPercent);
    const space  = Math.round(p.spacingPercent);
    const red    = Math.round(p.reductionPercent);

    // tip kód: 0S, 3S, 4S, 6S, YY
    let tipCode = '0S';
    if      (p.tipMode === 1) tipCode = '3S';
    else if (p.tipMode === 2) tipCode = 'YY';
    else if (p.tipMode === 3) tipCode = '6S';
    else if (p.tipMode === 4) tipCode = '4S';

    const tipScaleStr   = p.tipScale.toFixed(2);
    const tipOnlyFlag   = p.tipOnly     ? 'Y' : 'N';
    const tipCenterFlag = p.tipAtCenter ? 'Y' : 'N';
    const trunkFlag     = p.showTrunk   ? 'Y' : 'N';
    const arms          = p.armCount;
    const minRectStr    = p.minRectMm.toFixed(1);
    const growFlag      = p.growSmallRects ? 'Y' : 'N';

    // sorrend: Szög, Vastagság, Köz, Méretcsökkenés,
    // Végforma, Végforma méret, Csak végforma, Közép, Törzs,
    // Karok száma, Min. vastagság, Kisebbek növelése
    return (
      angle + '-' +
      ratio + '-' +
      space + '-' +
      red + '-' +
      tipCode + '-' +
      tipScaleStr + '-' +
      tipOnlyFlag + '-' +
      tipCenterFlag + '-' +
      trunkFlag + '-' +
      arms + '-' +
      minRectStr + '-' +
      growFlag
    );
  }

  // --- JPG mentése: aktuális canvas + aláírt kód ---

  function downloadJPEGWithCode(codeString) {
    const mainCanvas = document.getElementById('snowflakeCanvas');
    if (!mainCanvas) return;

    const exportCanvas = document.createElement('canvas');
    const extraHeight = 40; // hely a kódnak alul
    exportCanvas.width = mainCanvas.width;
    exportCanvas.height = mainCanvas.height + extraHeight;

    const ctx = exportCanvas.getContext('2d');

    // háttér
    ctx.fillStyle = '#001633';
    ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

    // hópehely képe (aktuális állapot) átmásolva
    ctx.drawImage(mainCanvas, 0, 0);

    // kód kiírása alul
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(codeString, exportCanvas.width / 2, mainCanvas.height + extraHeight / 2);

    const dataURL = exportCanvas.toDataURL('image/jpeg', 0.95);
    const a = document.createElement('a');
    a.href = dataURL;
    a.download = `PEHELY-${codeString}.jpg`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }

  // --- Egyszerű poligon-unió: élek felosztása + szegmens-osztályozás ---

  function buildLaserContoursExact(scaledPolys) {
    if (!scaledPolys || !scaledPolys.length) return [];

    const EPS = 1e-9;

    // Poligon-információk (bbox a gyorsításhoz)
    const polyInfos = scaledPolys.map(poly => {
      const unique = poly.slice(0, poly.length - 1);
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;
      for (const [x,y] of unique) {
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }
      return { poly, unique, minX, maxX, minY, maxY };
    });

    function pointInAnyPoly(x, y) {
      for (const info of polyInfos) {
        if (x < info.minX - 1e-6 || x > info.maxX + 1e-6 ||
            y < info.minY - 1e-6 || y > info.maxY + 1e-6) continue;
        if (pointInPolygon(x, y, info.poly)) return true;
      }
      return false;
    }

    // Élek listája
    const edges = [];
    for (let pi = 0; pi < scaledPolys.length; pi++) {
      const poly = scaledPolys[pi];
      const unique = poly.slice(0, poly.length - 1);
      const n = unique.length;
      if (n < 2) continue;
      for (let i = 0; i < n; i++) {
        const a = unique[i];
        const b = unique[(i + 1) % n];
        edges.push({
          ax: a[0], ay: a[1],
          bx: b[0], by: b[1],
          polyIndex: pi,
          splitTs: [0, 1]
        });
      }
    }

    function addParam(arr, t) {
      if (t < -EPS || t > 1 + EPS) return;
      t = Math.max(0, Math.min(1, t));
      for (let i = 0; i < arr.length; i++) {
        if (Math.abs(arr[i] - t) < 1e-6) return;
      }
      arr.push(t);
    }

    // Két él metszése, paraméterek gyűjtése
    function intersectEdges(e1, e2) {
      const p = { x: e1.ax, y: e1.ay };
      const r = { x: e1.bx - e1.ax, y: e1.by - e1.ay };
      const q = { x: e2.ax, y: e2.ay };
      const s = { x: e2.bx - e2.ax, y: e2.by - e2.ay };

      const rxs = r.x * s.y - r.y * s.x;
      const qmp = { x: q.x - p.x, y: q.y - p.y };
      const qpxr = qmp.x * r.y - qmp.y * r.x;
      const rr = r.x * r.x + r.y * r.y;
      const ss = s.x * s.x + s.y * s.y;

      if (Math.abs(rxs) < 1e-9) {
        // párhuzamos
        if (Math.abs(qpxr) > 1e-9) {
          return;
        }
        // kollineáris
        const t0 = ( (q.x - p.x) * r.x + (q.y - p.y) * r.y ) / rr;
        const t1 = ( (q.x + s.x - p.x) * r.x + (q.y + s.y - p.y) * r.y ) / rr;

        const tmin = Math.max(0, Math.min(t0, t1));
        const tmax = Math.min(1, Math.max(t0, t1));
        if (tmax < -1e-9 || tmin > 1 + 1e-9 || tmax - tmin < 1e-9) {
          return;
        }
        addParam(e1.splitTs, tmin);
        addParam(e1.splitTs, tmax);

        const u0 = ( (p.x - q.x) * s.x + (p.y - q.y) * s.y ) / ss;
        const u1 = ( (p.x + r.x - q.x) * s.x + (p.y + r.y - q.y) * s.y ) / ss;
        const umin = Math.max(0, Math.min(u0, u1));
        const umax = Math.min(1, Math.max(u0, u1));
        if (umax < -1e-9 || umin > 1 + 1e-9 || umax - umin < 1e-9) {
          return;
        }
        addParam(e2.splitTs, umin);
      } else {
        const t = (qmp.x * s.y - qmp.y * s.x) / rxs;
        const u = (qmp.x * r.y - qmp.y * r.x) / rxs;
        if (t >= -1e-9 && t <= 1 + 1e-9 && u >= -1e-9 && u <= 1 + 1e-9) {
          addParam(e1.splitTs, t);
          addParam(e2.splitTs, u);
        }
      }
    }

    // Élek felosztása metszéspontok szerint
    for (let i = 0; i < edges.length; i++) {
      for (let j = i + 1; j < edges.length; j++) {
        intersectEdges(edges[i], edges[j]);
      }
    }

    const rawSegments = [];
    for (const e of edges) {
      const { ax, ay, bx, by, splitTs } = e;
      splitTs.sort((a, b) => a - b);
      for (let k = 0; k < splitTs.length - 1; k++) {
        const t0 = splitTs[k];
        const t1 = splitTs[k + 1];
        if (t1 - t0 < 1e-5) continue;
        const x0 = ax + (bx - ax) * t0;
        const y0 = ay + (by - ay) * t0;
        const x1 = ax + (bx - ax) * t1;
        const y1 = ay + (by - ay) * t1;
        rawSegments.push({ x0, y0, x1, y1 });
      }
    }

    // Szegmensek osztályozása: határ-e?
    const boundarySegments = [];
    for (const seg of rawSegments) {
      const dx = seg.x1 - seg.x0;
      const dy = seg.y1 - seg.y0;
      const len = Math.hypot(dx, dy);
      if (len < 1e-4) continue;
      const mx = 0.5 * (seg.x0 + seg.x1);
      const my = 0.5 * (seg.y0 + seg.y1);
      const nx = -dy / len;
      const ny =  dx / len;
      const off = 1e-3;

      const px1 = mx + nx * off;
      const py1 = my + ny * off;
      const px2 = mx - nx * off;
      const py2 = my - ny * off;

      const inside1 = pointInAnyPoly(px1, py1);
      const inside2 = pointInAnyPoly(px2, py2);

      if (inside1 !== inside2) {
        boundarySegments.push(seg);
      }
    }

    // Szakaszokból kontúrok építése
    const pointKey = (x, y) => x.toFixed(4) + ',' + y.toFixed(4);

    const adjacency = new Map();

    function addEdgeAdj(x0, y0, x1, y1) {
      const k0 = pointKey(x0, y0);
      const k1 = pointKey(x1, y1);

      if (!adjacency.has(k0)) adjacency.set(k0, { pt: [x0, y0], neighbors: new Set() });
      if (!adjacency.has(k1)) adjacency.set(k1, { pt: [x1, y1], neighbors: new Set() });

      adjacency.get(k0).neighbors.add(k1);
      adjacency.get(k1).neighbors.add(k0);
    }

    for (const seg of boundarySegments) {
      addEdgeAdj(seg.x0, seg.y0, seg.x1, seg.y1);
    }

    const visited = new Set();
    const contours = [];

    for (const [key, node] of adjacency.entries()) {
      if (visited.has(key)) continue;

      const contour = [];
      let currentKey = key;
      let prevKey = null;

      while (currentKey && !visited.has(currentKey)) {
        visited.add(currentKey);
        const currentNode = adjacency.get(currentKey);
        contour.push(currentNode.pt);

        const neighbors = Array.from(currentNode.neighbors);
        let nextKey = null;

        for (const nk of neighbors) {
          if (nk !== prevKey) {
            nextKey = nk;
            if (!visited.has(nk)) break;
          }
        }

        prevKey = currentKey;
        currentKey = nextKey;

        if (!currentKey || currentKey === key) {
          break;
        }
      }

      if (contour.length >= 3) {
        if (contour[0] !== contour[contour.length - 1]) {
          contour.push(contour[0].slice());
        }
        contours.push(contour);
      }
    }

    return contours;
  }

  // --- DXF export: unió-kontúrok LWPOLYLINE-ként + JPG ---

  function exportDXFRectanglesSolid() {
    const scaled = getScaledPolys();
    if (!scaled) {
      alert('Nincs exportálható elem (a min. vastagság szűrés esetleg mindent eltüntetett).');
      return;
    }
    const { scaledPolys } = scaled;

    const contours = buildLaserContoursExact(scaledPolys);
    if (!contours.length) {
      alert('Nem sikerült kontúrt képezni a lézervágáshoz.');
      return;
    }

    let dxf = '';
    const NL = '\r\n';
    function add(code, value) {
      dxf += code + NL + value + NL;
    }

    add(0, 'SECTION');
    add(2, 'HEADER');
    add(0, 'ENDSEC');

    add(0, 'SECTION');
    add(2, 'ENTITIES');

    for (const contour of contours) {
      const unique = contour.slice(0, contour.length - 1);
      if (unique.length < 3) continue;

      add(0, 'LWPOLYLINE');
      add(8, '0'); // layer
      add(90, unique.length);
      add(70, 1);  // closed polyline

      for (const [x, y] of unique) {
        add(10, x.toFixed(4));
        add(20, y.toFixed(4));
      }
    }

    add(0, 'ENDSEC');
    add(0, 'EOF');

    const codeString = buildCodeString();
    const filename = `PEHELY-${codeString}.dxf`;

    // DXF mentés
    downloadDXF(dxf, filename);
    // JPG mentés
    downloadJPEGWithCode(codeString);
  }

  // --- Véletlen paraméterek ---

  function randomizeParams() {
    function randInt(min, max) {
      return Math.round(min + Math.random() * (max - min));
    }

    // Szög (10–90 között)
    const angle = randInt(10, 90);
    document.getElementById('angleSlider').value = angle;
    document.getElementById('angleInput').value  = angle;

    // Vastagság
    const ratio = randInt(8, 30);
    document.getElementById('ratioSlider').value = ratio;
    document.getElementById('ratioInput').value  = ratio;

    // Köz
    const spacing = randInt(15, 45);
    document.getElementById('spacingSlider').value = spacing;
    document.getElementById('spacingInput').value  = spacing;

    // Méretcsökkenés
    const reduction = randInt(20, 60);
    document.getElementById('reductionSlider').value = reduction;
    document.getElementById('reductionInput').value  = reduction;

    // Végforma
    const tipOptions = ['straight', 'tent', 'trap', 'hex', 'Y'];
    const idx = randInt(0, tipOptions.length - 1);
    document.getElementById('tipStyleSelect').value = tipOptions[idx];

    // Közép
    document.getElementById('tipCenterCheckbox').checked = (Math.random() < 0.5);

    // Minden más változatlan
    recomputeAndRedraw();
  }

  // --- Kontúr ki/be ---

  function toggleOutline() {
    showOutline = !showOutline;
    redraw();
  }

  // --- Init ---

  window.addEventListener('load', () => {
    syncInputPair('angleSlider',    'angleInput',    recomputeAndRedraw);
    syncInputPair('ratioSlider',    'ratioInput',    recomputeAndRedraw);
    syncInputPair('spacingSlider',  'spacingInput',  recomputeAndRedraw);
    syncInputPair('reductionSlider','reductionInput',recomputeAndRedraw);
    syncInputPair('armsSlider',     'armsInput',     recomputeAndRedraw);
    syncInputPair('minRectSlider',  'minRectInput',  recomputeAndRedraw);
    syncInputPair('tipScaleSlider', 'tipScaleInput', recomputeAndRedraw);

    document.getElementById('growSmallCheckbox')
      .addEventListener('change', recomputeAndRedraw);
    document.getElementById('tipStyleSelect')
      .addEventListener('change', recomputeAndRedraw);
    document.getElementById('tipOnlyCheckbox')
      .addEventListener('change', recomputeAndRedraw);
    document.getElementById('tipCenterCheckbox')
      .addEventListener('change', recomputeAndRedraw);
    document.getElementById('showTrunkCheckbox')
      .addEventListener('change', recomputeAndRedraw);

    document.getElementById('randomBtn')
      .addEventListener('click', randomizeParams);
    document.getElementById('toggleOutlineBtn')
      .addEventListener('click', toggleOutline);
    document.getElementById('exportSolidBtn')
      .addEventListener('click', exportDXFRectanglesSolid);

    // induló rajz az alapértékekkel
    recomputeAndRedraw();
  });
</script>
</body>
</html>
